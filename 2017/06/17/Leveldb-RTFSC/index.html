<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="leveldb,wal,storage,key-value,lsm," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="LevelDB: Read the Fucking Source Code.by grakra Code version: 1.19   3080a45 Increase leveldb version to 1.19.  Examplebuild leveldb library make -j 4 -B  demo #include &amp;lt;cassert&amp;gt; #include &amp;lt;io">
<meta name="keywords" content="leveldb,wal,storage,key-value,lsm">
<meta property="og:type" content="article">
<meta property="og:title" content="Leveldb_RTFSC">
<meta property="og:url" content="http://yoursite.com/2017/06/17/Leveldb-RTFSC/index.html">
<meta property="og:site_name" content="GRAKRA  三十年众生牛马 六十年诸佛龙象">
<meta property="og:description" content="LevelDB: Read the Fucking Source Code.by grakra Code version: 1.19   3080a45 Increase leveldb version to 1.19.  Examplebuild leveldb library make -j 4 -B  demo #include &amp;lt;cassert&amp;gt; #include &amp;lt;io">
<meta property="og:image" content="http://yoursite.com/2017/06/17/Leveldb-RTFSC/leveldb_images/leveldb_localfs.png">
<meta property="og:image" content="http://yoursite.com/2017/06/17/Leveldb-RTFSC/leveldb_images/leveldb_lsm.png">
<meta property="og:image" content="http://yoursite.com/2017/06/17/Leveldb-RTFSC/leveldb_images/wal.png">
<meta property="og:image" content="http://yoursite.com/2017/06/17/Leveldb-RTFSC/leveldb_images/leveldb_log.png">
<meta property="og:image" content="http://yoursite.com/2017/06/17/Leveldb-RTFSC/leveldb_images/leveldb_log_reader.png">
<meta property="og:image" content="http://yoursite.com/2017/06/17/Leveldb-RTFSC/leveldb_images/leveldb_log_writer.png">
<meta property="og:image" content="http://yoursite.com/2017/06/17/Leveldb-RTFSC/leveldb_images/leveldb_log_payload.png">
<meta property="og:image" content="http://yoursite.com/2017/06/17/Leveldb-RTFSC/leveldb_images/leveldb_log_commit.png">
<meta property="og:image" content="http://yoursite.com/2017/06/17/Leveldb-RTFSC/leveldb_images/leveldb_versionset.png">
<meta property="og:image" content="http://yoursite.com/2017/06/17/Leveldb-RTFSC/leveldb_images/leveldb_version.png">
<meta property="og:image" content="http://yoursite.com/2017/06/17/Leveldb-RTFSC/leveldb_images/leveldb_manifest_commit.png">
<meta property="og:image" content="http://yoursite.com/2017/06/17/Leveldb-RTFSC/leveldb_images/leveldb_manifest.png">
<meta property="og:image" content="http://yoursite.com/2017/06/17/Leveldb-RTFSC/leveldb_images/leveldb_memtable.png">
<meta property="og:image" content="http://yoursite.com/2017/06/17/Leveldb-RTFSC/leveldb_images/leveldb_skiplist.png">
<meta property="og:image" content="http://yoursite.com/2017/06/17/Leveldb-RTFSC/leveldb_images/leveldb_skiplist_iterator.png">
<meta property="og:image" content="http://yoursite.com/2017/06/17/Leveldb-RTFSC/leveldb_images/leveldb_memtable_key.png">
<meta property="og:image" content="http://yoursite.com/2017/06/17/Leveldb-RTFSC/leveldb_images/leveldb_skiplist1.png">
<meta property="og:image" content="http://yoursite.com/2017/06/17/Leveldb-RTFSC/leveldb_images/leveldb_skiplist2.png">
<meta property="og:image" content="http://yoursite.com/2017/06/17/Leveldb-RTFSC/leveldb_images/leveldb_makeroomforwrite.png">
<meta property="og:image" content="http://yoursite.com/2017/06/17/Leveldb-RTFSC/leveldb_images/leveldb_table.png">
<meta property="og:image" content="http://yoursite.com/2017/06/17/Leveldb-RTFSC/leveldb_images/leveldb_data_block.png">
<meta property="og:image" content="http://yoursite.com/2017/06/17/Leveldb-RTFSC/leveldb_images/leveldb_delta_encoding.png">
<meta property="og:image" content="http://yoursite.com/2017/06/17/Leveldb-RTFSC/leveldb_images/leveldb_filter_block.png">
<meta property="og:image" content="http://yoursite.com/2017/06/17/Leveldb-RTFSC/leveldb_images/leveldb_lrucache.png">
<meta property="og:image" content="http://yoursite.com/2017/06/17/Leveldb-RTFSC/leveldb_images/leveldb_iterator.png">
<meta property="og:image" content="http://yoursite.com/2017/06/17/Leveldb-RTFSC/leveldb_images/leveldb_options.png">
<meta property="og:updated_time" content="2017-06-17T05:50:14.226Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Leveldb_RTFSC">
<meta name="twitter:description" content="LevelDB: Read the Fucking Source Code.by grakra Code version: 1.19   3080a45 Increase leveldb version to 1.19.  Examplebuild leveldb library make -j 4 -B  demo #include &amp;lt;cassert&amp;gt; #include &amp;lt;io">
<meta name="twitter:image" content="http://yoursite.com/2017/06/17/Leveldb-RTFSC/leveldb_images/leveldb_localfs.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/06/17/Leveldb-RTFSC/"/>





  <title>Leveldb_RTFSC | GRAKRA  三十年众生牛马 六十年诸佛龙象</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">GRAKRA  三十年众生牛马 六十年诸佛龙象</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">grakra</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/17/Leveldb-RTFSC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="grakra">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GRAKRA  三十年众生牛马 六十年诸佛龙象">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Leveldb_RTFSC</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-17T13:00:45+08:00">
                2017-06-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="LevelDB-Read-the-Fucking-Source-Code"><a href="#LevelDB-Read-the-Fucking-Source-Code" class="headerlink" title="LevelDB: Read the Fucking Source Code."></a>LevelDB: Read the Fucking Source Code.</h1><h2 id="by-grakra"><a href="#by-grakra" class="headerlink" title="by grakra"></a>by grakra</h2><hr>
<p><code>Code version: 1.19   3080a45 Increase leveldb version to 1.19.</code></p>
<hr>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><h3 id="build-leveldb-library"><a href="#build-leveldb-library" class="headerlink" title="build leveldb library"></a>build leveldb library</h3><blockquote>
<pre><code>make -j 4 -B
</code></pre></blockquote>
<h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><blockquote>
<pre><code>#include &lt;cassert&gt;
#include &lt;iostream&gt;
using std::cerr;
using std::cout;
using std::endl;

#include &lt;string&gt;
using std::string;

#include &lt;algorithm&gt;
using std::transform;

#include &lt;functional&gt;
using std::ptr_fun;

#include &lt;cctype&gt;

#include &quot;leveldb/db.h&quot;

int main () {
    leveldb::DB* db;
    leveldb::Options options;
    options.create_if_missing = true;
    //options.error_if_exists = true;
    leveldb::Status s = leveldb::DB::Open(options, &quot;/tmp/testdb&quot;, &amp;db);
    if (!s.ok()) {
        cerr &lt;&lt; s.ToString() &lt;&lt;endl;
        exit(1);
    }

    string key1=&quot;foobar&quot;;

    s = db-&gt;Put(leveldb::WriteOptions(), key1, &quot;1&quot;);
    cout &lt;&lt;&quot;stat:&quot;&lt;&lt;s.ToString()&lt;&lt;endl;

    leveldb::ReadOptions options1;
    options1.snapshot = db-&gt;GetSnapshot();
    string value1;
    s = db-&gt;Get(options1, key1, &amp;value1);
    cout &lt;&lt;&quot;stat:&quot;&lt;&lt;s.ToString()&lt;&lt;endl;
    cout &lt;&lt;&quot;value=&quot;&lt;&lt;value1&lt;&lt;endl;

    s = db-&gt;Put(leveldb::WriteOptions(), key1, &quot;111&quot;);
    cout &lt;&lt;&quot;stat:&quot;&lt;&lt;s.ToString()&lt;&lt;endl;
    value1.resize(0);
    s = db-&gt;Get(leveldb::ReadOptions(), key1, &amp;value1);
    cout &lt;&lt;&quot;stat:&quot;&lt;&lt;s.ToString()&lt;&lt;endl;
    cout &lt;&lt;&quot;value=&quot;&lt;&lt;value1&lt;&lt;endl;

    value1.resize(0);
    s = db-&gt;Get(options1, key1, &amp;value1);
    cout &lt;&lt;&quot;stat:&quot;&lt;&lt;s.ToString()&lt;&lt;endl;
    cout &lt;&lt;&quot;value=&quot;&lt;&lt;value1&lt;&lt;endl;

    if (db != nullptr ) {
        delete db;
    }
    cout &lt;&lt;&quot;delete db&quot;&lt;&lt;endl;
    return 0;
}
</code></pre></blockquote>
<h3 id="Build-Demo"><a href="#Build-Demo" class="headerlink" title="Build Demo"></a>Build Demo</h3><blockquote>
<pre><code>g++ -g -O0 -rdynamic -std=c++0x -static -L out-static -I include/ -o demo demo.cc  -lleveldb -lpthread
</code></pre></blockquote>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><h3 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h3><ol>
<li>KeyValue</li>
<li>Persistent</li>
<li>Embedded</li>
<li>Snapshot isolation</li>
<li>Thread-safety</li>
<li>Configurable</li>
<li>High-performance (<a href="https://github.com/google/leveldb" target="_blank" rel="external">https://github.com/google/leveldb</a>)</li>
</ol>
<h3 id="Inventory-of-data-directory"><a href="#Inventory-of-data-directory" class="headerlink" title="Inventory of data directory"></a>Inventory of data directory</h3><p><img src="leveldb_images/leveldb_localfs.png" alt="image"></p>
<h3 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h3><p><img src="leveldb_images/leveldb_lsm.png" alt="image"></p>
<hr>
<h2 id="LSM-Log-Structured-Merge-tree"><a href="#LSM-Log-Structured-Merge-tree" class="headerlink" title="LSM (Log-Structured Merge tree)"></a>LSM (Log-Structured Merge tree)</h2><p><code>O’Neil P, Cheng E, Gawlick D, et al. The log-structured merge-tree (LSM-tree)[J]. Acta Informatica, 1996, 33(4): 351-385.</code></p>
<hr>
<h2 id="WAL-Write-Ahead-Logging"><a href="#WAL-Write-Ahead-Logging" class="headerlink" title="WAL (Write-Ahead Logging)"></a>WAL (Write-Ahead Logging)</h2><h3 id="sketch-of-WAL"><a href="#sketch-of-WAL" class="headerlink" title="sketch of WAL"></a>sketch of WAL</h3><p><strong>WHY</strong></p>
<blockquote>
<ul>
<li>WAL is essential of standalone local storage systems.</li>
<li>standalone local storage system is substantialization of WAL.</li>
<li>WAL guarantees that committed data survive in power outages and process crashes.</li>
<li>WAL is key to ACIDity of transaction processing.</li>
<li>Data rate of sequential access is about three orders of magnitude higher than counterpart of random access.</li>
</ul>
</blockquote>
<p><strong>HOW</strong></p>
<p><strong>Stonebraker</strong> says:</p>
<blockquote>
<pre><code>1. Each modification to a database page should generate a log record, and the log record must be flushed to the log device before the database page is flushed.

2. Database log records must be flushed in order; log record r cannot be flushed until all log records preceding r are flushed.

3. Upon a transaction commit request, a commit log record must be flushed to the log device before the commit request returns successfully.

------------------------ Architecture of a Database System
</code></pre></blockquote>
<p><strong><a href="http://research.microsoft.com/pubs/66814/tr-2008-25.pdf" target="_blank" rel="external">Lin, W., &amp; Yang, M. (2008). PacificA : Replication in Log-Based Distributed Storage Systems</a></strong><br><img src="leveldb_images/wal.png" alt="image"></p>
<hr>
<h3 id="WAL-in-LevelDB"><a href="#WAL-in-LevelDB" class="headerlink" title="WAL in LevelDB"></a>WAL in LevelDB</h3><h4 id="features"><a href="#features" class="headerlink" title="features"></a><strong>features</strong></h4><ul>
<li>Log records separate from its payload.(<strong>abstraction</strong>)</li>
<li>Log writers/readers separate from underlying file operations.(<strong>portability</strong>)</li>
<li>WAL is used to make both db data and db metadata persistent. </li>
</ul>
<h4 id="log-format"><a href="#log-format" class="headerlink" title="log format"></a><strong>log format</strong></h4><p><img src="leveldb_images/leveldb_log.png" alt="image"></p>
<ul>
<li>a log is AOF that consists of  several blocks which are fixed-size except last one.</li>
<li>a block is a contiguous range that is composes of log record.</li>
<li>a blob being appended to the log may cross borders of blocks. a cross-border blob is segmented into one kFirstType records, zero or more kMiddleType records and one kLastType records.</li>
<li>a non-cross-border blob is kFullType.</li>
<li>if a block remains 7B, then a empty record is appended to the block. </li>
<li>if a block remains less than 7B, then a trailor (zero paddings) is appended.</li>
<li>kZeroType records are generated by RandomAccessFile that built upon mmap syscall.<strong>n/a</strong>.</li>
</ul>
<h4 id="implementation"><a href="#implementation" class="headerlink" title="implementation"></a><strong>implementation</strong></h4><p><strong>log format definition</strong></p>
<blockquote>
<pre><code>db/dbformat.h
db/dbformat.cc
</code></pre></blockquote>
<p><strong>log::Reader</strong></p>
<p><img src="leveldb_images/leveldb_log_reader.png" alt="image"></p>
<blockquote>
<pre><code>db/log_reader.h
db/log_reader.cc
</code></pre></blockquote>
<p><strong>log::Writer</strong></p>
<p><img src="leveldb_images/leveldb_log_writer.png" alt="image"></p>
<blockquote>
<pre><code>db/log_writer.h 
db/log_writer.cc
</code></pre></blockquote>
<p><strong>underlying file operations</strong></p>
<table>
<thead>
<tr>
<th>Abstract class(include/leveldb/env.h)</th>
<th>Implementation(util/env_posix.cc)</th>
<th>usage</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>WritableFile</strong></td>
<td><strong>PosixWritableFile</strong>(“w”, fwrite)</td>
<td>backbone of <strong>TableBuilder</strong>(writing SSTable)</td>
</tr>
<tr>
<td><strong>AppendableFile</strong></td>
<td><strong>PosixAppendableFile</strong>(“a”, fwrite)</td>
<td>backbone of Log::Writer</td>
</tr>
<tr>
<td><strong>SequentialFile</strong></td>
<td><strong>PosixSequentialFile(“r”, fread)</strong></td>
<td>backbone of <strong>Log::Reader</strong></td>
</tr>
<tr>
<td><strong>RandomAccessFile</strong></td>
<td><strong>PosixMmapReadableFile</strong>(O_RDONLY, mmap)</td>
<td>backbone of <strong>Table</strong>(reading SSTable), prefered if running on 64-bit platforms and the mmap slots(1000) are not hausted. </td>
</tr>
<tr>
<td><strong>RandomAccessFile</strong></td>
<td><strong>PosixRandomAccessFile</strong>(O_RDONLY, pread)</td>
<td>backbone of <strong>Table</strong>(reading SSTable), used if mmap is not allowed.</td>
</tr>
</tbody>
</table>
<p><strong>DB Data Manipulation</strong></p>
<blockquote>
<p><strong>log record payload</strong><br><img src="leveldb_images/leveldb_log_payload.png" alt="image"></p>
<p><strong>commit log record</strong><br><img src="leveldb_images/leveldb_log_commit.png" alt="image"></p>
<p><strong>data/control flow</strong></p>
<ul>
<li><strong>step1: invoke DB::{Put, Delete, Write} to manipulate db</strong></li>
</ul>
<pre><code>    Status DB::Put(const WriteOptions&amp; opt, const Slice&amp; key, const Slice&amp; value) {
      WriteBatch batch;
      batch.Put(key, value);
      return Write(opt, &amp;batch);
    }

    Status DB::Delete(const WriteOptions&amp; opt, const Slice&amp; key) {
      WriteBatch batch;
      batch.Delete(key);
      return Write(opt, &amp;batch);
    }
</code></pre><ul>
<li><strong>step2: convert operands and opcodes into WriteBatch and Write</strong></li>
</ul>
<pre><code>    db/db_impl.cc-1193 Status DBImpl::Write(const WriteOptions&amp; options, WriteBatch* my_batch)
</code></pre><ul>
<li><strong>step3: a Writer object made of WriteBatch is pushed onto the back of the Writer queue.</strong></li>
</ul>
<pre><code>    // db/db_impl.cc-1194 Write
      Writer w(&amp;mutex_);
      w.batch = my_batch;
      w.sync = options.sync;
      w.done = false;

      MutexLock l(&amp;mutex_);
      writers_.push_back(&amp;w);
      while (!w.done &amp;&amp; &amp;w != writers_.front()) {
        w.cv.Wait();
      }
      if (w.done) {
        return w.status;
      }
</code></pre><ul>
<li><strong>step4:  invoke function MakeRoomForWrite to attempt to switch log</strong></li>
</ul>
<pre><code>    db/db_impl.cc-1209 Write
</code></pre><ol>
<li>slow down write speed,</li>
<li>switch log,</li>
<li>trigger background CompactMemTable task(minor compaction),</li>
<li>trigger background DoCompactionWork task(major compaction).</li>
</ol>
<ul>
<li><strong>step5: invoke function BuildBatchGroup for group commit</strong></li>
</ul>
<pre><code>    // db/db_impl.cc-1213 Write
        WriteBatch* updates = BuildBatchGroup(&amp;last_writer);
        WriteBatchInternal::SetSequence(updates, last_sequence + 1);
        last_sequence += WriteBatchInternal::Count(updates);
</code></pre><ul>
<li><strong>step6: invoke function AddRecord to flush operation records to the log</strong></li>
</ul>
<pre><code>    // db/db_impl.cc-1223 Write
          status = log_-&gt;AddRecord(WriteBatchInternal::Contents(updates));
          bool sync_error = false;
          if (status.ok() &amp;&amp; options.sync) {
            status = logfile_-&gt;Sync();
            if (!status.ok()) {
              sync_error = true;
            }
          }
</code></pre><ul>
<li><strong>step7: invoke funtion InsertInto to apply new operation records to MemTable</strong></li>
</ul>
<pre><code>    // db/db_impl.cc-1232 Write
            status = WriteBatchInternal::InsertInto(updates, mem_);
</code></pre><ul>
<li><strong>step8: return on success or failure</strong></li>
</ul>
</blockquote>
<p><strong>DB Metadata Manipulation</strong></p>
<blockquote>
<p><strong>VersionSet records in-core metadata</strong></p>
<ul>
<li><strong>next file number</strong>: monotonic increasing number for naming log, table and MANIFEST file.</li>
<li><strong>log file number</strong>: specify current WAL that keeps db data operations.</li>
<li><strong>previous log file number</strong>: previous log file corresponding to immutable MemTable.</li>
<li><strong>last sequnence number</strong>: monotonic increasing number  assigned to db operations, like timestamp, KeyValue with greater sequence number is newer then the counterpart with less sequence number.</li>
<li><strong>compact pointers</strong>: the file from which the next compaction starts in each level.</li>
<li><strong>current Version</strong>: keep files that each level owns.</li>
</ul>
<p><img src="leveldb_images/leveldb_versionset.png" alt="image"><br><img src="leveldb_images/leveldb_version.png" alt="image"></p>
<p><strong>MANIFEST file is WAL log that stores metadata operation records</strong></p>
<p><strong>CURRENT file stores filename of the current MANIFEST file</strong></p>
<p><strong>Modify VersionSet</strong><br><img src="leveldb_images/leveldb_manifest_commit.png" alt="image"><br><img src="leveldb_images/leveldb_manifest.png" alt="image">    </p>
</blockquote>
<hr>
<h2 id="DB-manipulation"><a href="#DB-manipulation" class="headerlink" title="DB manipulation"></a>DB manipulation</h2><hr>
<h3 id="1-Write"><a href="#1-Write" class="headerlink" title="1.Write"></a>1.Write</h3><p><strong>key points</strong></p>
<ul>
<li><strong>Put</strong>, <strong>Delete</strong> and <strong>Write</strong> invocations are canonicalized into uniform <strong>Write</strong> invocations.</li>
<li>operation records are appended to <strong>WAL log</strong> before they are applyed to <strong>MemTable</strong>.</li>
</ul>
<p>HOW to write WAL log is detailed in the previous sections, thus, only MemTable operations are depicted below.</p>
<p><strong>source files</strong></p>
<blockquote>
<pre><code>db/memtable.h
db/memtable.cc
db/skiplist.h
util/arena.h
util/arena.cc
</code></pre></blockquote>
<h4 id="MemTable"><a href="#MemTable" class="headerlink" title="MemTable"></a><strong>MemTable</strong></h4><p><strong>brief introduction to MemTable</strong></p>
<ul>
<li>A MemTable instance consists of a SkipList  instance and a Arena instance(memory allocator).</li>
<li>SkipList is insertable, non-deleteable.</li>
<li>SkipList is not thread-safe, so callers (member  functions of SkipList are callees) should guarantee synchronization by IPC utilities.</li>
<li>Only one writer is allowed to mutate SkipList.</li>
<li>When the writer enters critical region, mulitple readers  are also allowed read SkipList.</li>
<li>Arena is a memory allocator, which allocates a new page by c++ <code>new operator</code> when the old page allocated previously is ran out,  then allocate small pieces from the page for storing SkipList nodes.</li>
</ul>
<p><strong>MemTable member</strong></p>
<p><img src="leveldb_images/leveldb_memtable.png" alt="image"></p>
<p><strong>SkipList member</strong></p>
<p><img src="leveldb_images/leveldb_skiplist.png" alt="image"><br><img src="leveldb_images/leveldb_skiplist_iterator.png" alt="image"></p>
<p><strong>MemTable Entry</strong></p>
<p><img src="leveldb_images/leveldb_memtable_key.png" alt="image"></p>
<blockquote>
<pre><code>// db/memtable.cc-82
void MemTable::Add(SequenceNumber s, ValueType type,
                   const Slice&amp; key,
                   const Slice&amp; value) {
  // Format of an entry is concatenation of:
  //  key_size     : varint32 of internal_key.size()
  //  key bytes    : char[internal_key.size()]
  //  value_size   : varint32 of value.size()
  //  value bytes  : char[value.size()]
  size_t key_size = key.size();
  size_t val_size = value.size();
  size_t internal_key_size = key_size + 8;
  const size_t encoded_len =
      VarintLength(internal_key_size) + internal_key_size +
      VarintLength(val_size) + val_size;
  char* buf = arena_.Allocate(encoded_len);
  char* p = EncodeVarint32(buf, internal_key_size);
  memcpy(p, key.data(), key_size);
  p += key_size;
  EncodeFixed64(p, (s &lt;&lt; 8) | type);
  p += 8;
  p = EncodeVarint32(p, val_size);
  memcpy(p, value.data(), val_size);
  assert((p + val_size) - buf == encoded_len);
  table_.Insert(buf);
}
</code></pre></blockquote>
<h4 id="SkipList"><a href="#SkipList" class="headerlink" title="SkipList"></a>SkipList</h4><p><strong>SkipList Data Structure</strong></p>
<p><strong>skiplist contains (0.5, 1, 1.5, 2, 3 and 3.5)</strong></p>
<p><img src="leveldb_images/leveldb_skiplist1.png" alt="image"></p>
<p><strong>after inserting 1.7</strong></p>
<p><img src="leveldb_images/leveldb_skiplist2.png" alt="image"></p>
<p><strong>key points on SkipList</strong></p>
<ul>
<li>The code of SkipList is handful, but the update rule of SkipList is somewhat obscure.</li>
<li>However, turn the algorithm into a graph, it’s very intuitive.</li>
<li>SkipList is ordered unidirectional linked list consists of several nodes that contain a payload, a randomized height and next pointers whose number equals to the height.</li>
<li>In MemTable, the payload of SkipList node is the MemTable entry.</li>
<li>If SkipList node’s height is N, then the node has N levels each of which has a next pointer.</li>
<li>The next pointer in each level of the node points to the nearest node whom it can “see” in the front of iteself. the higher nodes would hide the lower counterparts.</li>
<li>When lookup some key, start with the highest level of the dummy node <code>head_</code>, if the next node in the current level is less than the key, then walk forward; otherwise walk upward(i.e. level–); finally, return the node until level equals to 0. <strong><code>db/skiplist.h:262 FindGreaterOrEqual</code></strong></li>
</ul>
<p><strong>KeyComparator</strong></p>
<blockquote>
<pre><code>// db/memtable.cc-33
int MemTable::KeyComparator::operator()(const char* aptr, const char* bptr)
    const {
  // Internal keys are encoded as length-prefixed strings.
  Slice a = GetLengthPrefixedSlice(aptr);
  Slice b = GetLengthPrefixedSlice(bptr);
  return comparator.Compare(a, b);
}

// db/memtable.cc-14
static Slice GetLengthPrefixedSlice(const char* data) {
  uint32_t len;
  const char* p = data;
  p = GetVarint32Ptr(p, p + 5, &amp;len);  // +5: we assume &quot;p&quot; is not corrupted
  return Slice(p, len);
}

// db/dbformat.cc-50
int InternalKeyComparator::Compare(const Slice&amp; akey, const Slice&amp; bkey) const {
  // Order by:
  //    increasing user key (according to user-supplied comparator)
  //    decreasing sequence number
  //    decreasing type (though sequence# should be enough to disambiguate)
  int r = user_comparator_-&gt;Compare(ExtractUserKey(akey), ExtractUserKey(bkey));
  if (r == 0) {
    const uint64_t anum = DecodeFixed64(akey.data() + akey.size() - 8);
    const uint64_t bnum = DecodeFixed64(bkey.data() + bkey.size() - 8);
    if (anum &gt; bnum) {
      r = -1;
    } else if (anum &lt; bnum) {
      r = +1;
    }
  }
  return r;
}

// util/comparator.cc-25 BytewiseComparatorImpl
  virtual int Compare(const Slice&amp; a, const Slice&amp; b) const {
    return a.compare(b);
  }
</code></pre></blockquote>
<p><strong>MemTable operations</strong></p>
<ul>
<li><strong>Add</strong>: SkipList.Insert</li>
<li><strong>Get</strong>: SkipList::Iterator.Seek</li>
<li><strong>MemTable::Interator</strong>: just wark forward along level 0 of SkipList</li>
</ul>
<hr>
<h3 id="2-Compaction"><a href="#2-Compaction" class="headerlink" title="2.Compaction"></a>2.Compaction</h3><p><strong>key points of Compaction</strong></p>
<ul>
<li><strong>Minor compaction</strong>: dump a immutable MemTable into a SSTable on disk.</li>
<li><strong>Major compaction</strong>: merge lower sparse SSTables into upper dense SSTables.</li>
<li>An active MemTable is sealed and becomes immutable when the predicate <code>mem_-&gt;ApproximateMemoryUsage() &lt;= options_.write_buffer_size</code>  is not holden(<code>db/db_impl.cc:1341</code>). <code>write_buffer_size</code> is 4MB in default.</li>
<li>An Immutable MemTable should be dumped onto disk before DB switchs a new log and open up a new MemTable, so the memory may hold two MemTable, the one is sealed, the other is active. Obsolete MemTables may be postponed to release if someone is reading them.</li>
<li>there is only one backgroup thread that do campacting.</li>
</ul>
<p><strong>synchronize foreground CRUD threads and the background compaction thread</strong></p>
<ul>
<li>Readers never wait for background compaction thread, only writers wait.</li>
<li>the foreground threads and the background thread are synchronzed by mutex and condition variable.(<code>man thread.h</code>)</li>
</ul>
<p><strong>MakeRoomForWrite wait completion of compactions</strong></p>
<blockquote>
<pre><code>// db/db_impl.cc-1317
Status DBImpl::MakeRoomForWrite(bool force) {
  mutex_.AssertHeld();
  assert(!writers_.empty());
  bool allow_delay = !force;
  Status s;
  while (true) {
    if (!bg_error_.ok()) {
      // Yield previous error
      s = bg_error_;
      break;
    } else if ( 
        allow_delay &amp;&amp;
        versions_-&gt;NumLevelFiles(0) &gt;= config::kL0_SlowdownWritesTrigger) {
      // We are getting close to hitting a hard limit on the number of
      // L0 files.  Rather than delaying a single write by several
      // seconds when we hit the hard limit, start delaying each
      // individual write by 1ms to reduce latency variance.  Also,
      // this delay hands over some CPU to the compaction thread in
      // case it is sharing the same core as the writer.
      mutex_.Unlock();
      env_-&gt;SleepForMicroseconds(1000);
      allow_delay = false;  // Do not delay a single write more than once
      mutex_.Lock();
    } else if (!force &amp;&amp;
               (mem_-&gt;ApproximateMemoryUsage() &lt;= options_.write_buffer_size)) {
      // There is room in current memtable
      break;
    } else if (imm_ != NULL) {
      // We have filled up the current memtable, but the previous
      // one is still being compacted, so we wait.
      Log(options_.info_log, &quot;Current memtable full; waiting...\n&quot;);
      bg_cv_.Wait();
    } else if (versions_-&gt;NumLevelFiles(0) &gt;= config::kL0_StopWritesTrigger) {
      // There are too many level-0 files.
      Log(options_.info_log, &quot;Too many L0 files; waiting...\n&quot;);
      bg_cv_.Wait();
    } else {
      // Attempt to switch to a new memtable and trigger compaction of old
      assert(versions_-&gt;PrevLogNumber() == 0);
      uint64_t new_log_number = versions_-&gt;NewFileNumber();
      WritableFile* lfile = NULL;
      s = env_-&gt;NewWritableFile(LogFileName(dbname_, new_log_number), &amp;lfile);
      if (!s.ok()) {
        // Avoid chewing through file number space in a tight loop.
        versions_-&gt;ReuseFileNumber(new_log_number);
        break;
      }    
      delete log_;
      delete logfile_;
      logfile_ = lfile;
      logfile_number_ = new_log_number;
      log_ = new log::Writer(lfile);
      imm_ = mem_;
      has_imm_.Release_Store(imm_);
      mem_ = new MemTable(internal_comparator_);
      mem_-&gt;Ref();
      force = false;   // Do not force another compaction if have room
      MaybeScheduleCompaction();
    }    
  }
  return s;
}
</code></pre></blockquote>
<p><img src="leveldb_images/leveldb_makeroomforwrite.png" alt="image"></p>
<p><strong>background compaction thread</strong></p>
<blockquote>
<pre><code>db/db_impl.cc-685 void DBImpl::BackgroundCompaction()
db/db_impl.cc-666 void DBImpl::BackgroundCall()
db/db_impl.cc-662 void DBImpl::BGWork(void* db)
db/db_impl.cc-658 env_-&gt;Schedule(&amp;DBImpl::BGWork, this);
db/db_impl.cc-644 void DBImpl::MaybeScheduleCompaction()
</code></pre></blockquote>
<p><strong>BackgroundCompaction function do the compaction finally</strong></p>
<ul>
<li>Minor compaction take precedence over major compaction.</li>
<li>Minor compaction invokes <code>CompactMemTable</code>(<code>db/db_impl.cc-689</code>).</li>
<li>Major compaction first invokes <code>VersionSet::PickCompaction</code>(<code>db/db_impl.cc-710</code>), then invokes <code>DoCompactionWork</code>(<code>db/db_impl.cc-738</code>)</li>
</ul>
<h4 id="LevelDB-SSTable-Layout"><a href="#LevelDB-SSTable-Layout" class="headerlink" title="LevelDB SSTable Layout"></a><strong>LevelDB SSTable Layout</strong></h4><p><img src="leveldb_images/leveldb_table.png" alt="image"></p>
<ul>
<li>A SSTable contains several data blocks, one index block, one meta index block, one optional filter block and a footer.</li>
</ul>
<blockquote>
<pre><code>include/leveldb/table_builder.h
table/table_builder.cc
</code></pre></blockquote>
<p><strong>data block layout</strong></p>
<p><img src="leveldb_images/leveldb_data_block.png" alt="image"></p>
<ul>
<li>A data block contains sorted KeyValue pairs.</li>
<li>Index block and meta index block are special data blocks</li>
<li>A data blocks splited into restart intervals in every 16 adjacent keys.</li>
<li>In a restart interval, keys adopt a fashion of delta encoding.</li>
<li>Delta encoding: given a certain key, split it into two parts, the one part is longest common prefix of itself and the previous key, which called shared part; the other part is non-shared part, so just use triple tuple (size of shared part, size of non-shared part, non-shared part) to represent the key. both sizes are stored as varint32.</li>
</ul>
<p><img src="leveldb_images/leveldb_delta_encoding.png" alt="image"></p>
<blockquote>
<pre><code>table/block_builder.h
table/block_builder.cc
</code></pre></blockquote>
<p><strong>filter block layout</strong></p>
<p><img src="leveldb_images/leveldb_filter_block.png" alt="image"></p>
<ul>
<li>a filter is created for every 2KB.</li>
<li>a data block maximum size approximates to 4KB, snappy is used to compress data block. so a persistent data block in SSTable may be less than 2KB, or more than 4KB, thus multiple data blocks may be mapped into one filter.</li>
</ul>
<blockquote>
<pre><code>table/filter_block.h
table/filter_block.cc
util/bloom.cc
</code></pre></blockquote>
<h4 id="When-to-do-compaction"><a href="#When-to-do-compaction" class="headerlink" title="When to do compaction"></a><strong>When to do compaction</strong></h4><p><strong>MaybeScheduleCompaction function submits compaction task to the thread</strong></p>
<blockquote>
<pre><code>// db/db_impl.cc:644
void DBImpl::MaybeScheduleCompaction() {
  mutex_.AssertHeld();
  if (bg_compaction_scheduled_) {
    // Already scheduled
  } else if (shutting_down_.Acquire_Load()) {
    // DB is being deleted; no more background compactions
  } else if (!bg_error_.ok()) {
    // Already got an error; no more changes
  } else if (imm_ == NULL &amp;&amp;
             manual_compaction_ == NULL &amp;&amp;
             !versions_-&gt;NeedsCompaction()) {
    // No work to be done
  } else {
    bg_compaction_scheduled_ = true;
    env_-&gt;Schedule(&amp;DBImpl::BGWork, this);
  }
}
</code></pre></blockquote>
<p><strong>the time to launch compaction task</strong></p>
<table>
<thead>
<tr>
<th><strong>Operation</strong></th>
<th><strong>file-number</strong></th>
<th><strong>explanation</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Get</td>
<td>db/db_impl.cc-1147</td>
<td>after read an Key-Value pair</td>
</tr>
<tr>
<td>Write</td>
<td>db/db_impl.cc-1374</td>
<td>after created a new MemTable </td>
</tr>
<tr>
<td>RecordReadSample</td>
<td>db/db_impl.cc-1170</td>
<td>after walked througth several KeyValue pairs</td>
</tr>
<tr>
<td>BackgroundCall</td>
<td>db/db_impl.cc-681</td>
<td>after the background thread has complete the previous compaction task.</td>
</tr>
<tr>
<td>Open</td>
<td>db/db_impl.cc-1521</td>
<td>when open and recover LevelDB.</td>
</tr>
</tbody>
</table>
<h4 id="Minor-compaction-CompactMemTable"><a href="#Minor-compaction-CompactMemTable" class="headerlink" title="Minor compaction: CompactMemTable"></a><strong>Minor compaction: CompactMemTable</strong></h4><p><strong>key points</strong></p>
<ul>
<li>Minor compaction dumps a sealed MemTable to a SSTable on disk, add the new SSTable to a new current Version, and delete obsolete logs and MemTables.</li>
<li>Minor compaction takes priority over majar compaction, since only up to two MemTables are permitted to reside in memory.</li>
</ul>
<p><strong>backtrace</strong></p>
<blockquote>
<pre><code>db/db_impl.cc-487 Status DBImpl::WriteLevel0Table
db/db_impl.cc-533 void DBImpl::CompactMemTable
</code></pre></blockquote>
<p><strong>CompactMemTable</strong></p>
<ul>
<li>step1: invoke WriteLevel0Table to create SSTable from <code>imm_</code></li>
<li>step2: log PrevLogNumber, LogNumber and file addition/deletion in MANIFEST, then apply to the VersionSet.</li>
<li>step3: drop refcount of the <code>imm_</code> and set <code>imm_</code> to NULL.</li>
<li><p>step4: delete obsolete files.</p>
</li>
<li><p><strong>NOTICE1</strong>: The contest between the compaction thread and the writer,  the former manipulates immutable MemTable(<code>imm_</code>), while the latter manipulates mutable MemTable(<code>mem_</code>). Only if immutable MemTable resides in memory and a new MemTable is about to be created, then the writer waits for compaction thread to finish its work.</p>
</li>
<li><strong>NOTICE2</strong>: The contest between the compaction thread and the reader. both MemTable and Version are reference-counted. When reading a MemTable/Version,  MemTable/Version is assigned to a pointer, then call Ref method to increase the refcount; when the pointer is not need any more, then call Unref method to drop the refcount, delete MemTable/Version if its refcount reaches zero; the compaction thread creates a new Version instead of altering the current Version. </li>
</ul>
<blockquote>
<pre><code>// db/memtable.h-26
  // Increase reference count.
  void Ref() { ++refs_; }

  // Drop reference count.  Delete if no more references exist.
  void Unref() {
    --refs_;
    assert(refs_ &gt;= 0); 
    if (refs_ &lt;= 0) {
      delete this;
    } 
  }

// db/version_set.cc-473
void Version::Ref() {
  ++refs_;
}

void Version::Unref() {
  assert(this != &amp;vset_-&gt;dummy_versions_);
  assert(refs_ &gt;= 1);
  --refs_;
  if (refs_ == 0) { 
    delete this;
  }
}

// db/version_set.cc-57
Version::~Version() {
  assert(refs_ == 0);

  // Remove from linked list
  prev_-&gt;next_ = next_;
  next_-&gt;prev_ = prev_;

  // Drop references to files
  for (int level = 0; level &lt; config::kNumLevels; level++) {
    for (size_t i = 0; i &lt; files_[level].size(); i++) {
      FileMetaData* f = files_[level][i];
      assert(f-&gt;refs &gt; 0);
      f-&gt;refs--;
      if (f-&gt;refs &lt;= 0) { 
        delete f;
      }
    }
  }
}
</code></pre></blockquote>
<p><strong>WriteLevel0Table</strong></p>
<p><strong>step1</strong>: call BuildTable to create SSTable.</p>
<ul>
<li>BuildTable create a TableBuilder object to build SSTable. BuildTable::Rep is representation of SSTable. BuildTable and BuildTable::Rep comply with bridge pattern.</li>
<li>BuildTable invoke functions as follow to build SSTable.</li>
</ul>
<blockquote>
<ul>
<li>TableBuilder::TableBuilder: initialize TableBuilder object.</li>
<li>TableBuilder::Add: iterate MemTable and add KeyValue pairs to TableBuilder.</li>
<li>TableBuilder::Finish: append filter block, index block, meta data block, footer to SSTable.</li>
<li>TableBuilder::Abandon: abandon buiding.</li>
<li>WritableFile::Sync: fsync SSTable file.</li>
<li>WritableFile::Close: close SSTable file.</li>
<li>TableCache::NewIterator: load the SSTable into TableCache to see if the SSTable is built successfully.</li>
</ul>
</blockquote>
<p><strong>step2</strong>: call PickLevelForMemTableOutput to decide which level the new SSTable dwells in.</p>
<ul>
<li>the new SSTable is not always placed in level-0, it can aslo be placed in level-L (L ranges from 1 to config::kMaxMemCompactLevel(defaults 2)) if the SSTable is not overlapped with level-L+1 and total bytes of overlapped SSTables in level-L+2 is not greater than kMaxGrandParentOverlapBytes(default 20MB).</li>
</ul>
<blockquote>
<pre><code>// db/version_set.cc-493
int Version::PickLevelForMemTableOutput(
    const Slice&amp; smallest_user_key,
    const Slice&amp; largest_user_key) {
  int level = 0;
  if (!OverlapInLevel(0, &amp;smallest_user_key, &amp;largest_user_key)) {
    // Push to next level if there is no overlap in next level,
    // and the #bytes overlapping in the level after that are limited.
    InternalKey start(smallest_user_key, kMaxSequenceNumber, kValueTypeForSeek);
    InternalKey limit(largest_user_key, 0, static_cast&lt;ValueType&gt;(0));
    std::vector&lt;FileMetaData*&gt; overlaps;
    while (level &lt; config::kMaxMemCompactLevel) {
      if (OverlapInLevel(level + 1, &amp;smallest_user_key, &amp;largest_user_key)) {
        break;
      }
      if (level + 2 &lt; config::kNumLevels) {
        // Check that file does not overlap too many grandparent bytes.
        GetOverlappingInputs(level + 2, &amp;start, &amp;limit, &amp;overlaps);
        const int64_t sum = TotalFileSize(overlaps);
        if (sum &gt; kMaxGrandParentOverlapBytes) {
          break;
        }
      }
      level++;
    }
  }
  return level;
}
</code></pre></blockquote>
<h4 id="Major-compaction-PickCompaction-and-DoCompactionWork"><a href="#Major-compaction-PickCompaction-and-DoCompactionWork" class="headerlink" title="Major compaction: PickCompaction and DoCompactionWork"></a><strong>Major compaction: PickCompaction and DoCompactionWork</strong></h4><p><strong>PickCompaction: which SSTable need to be compacted?</strong></p>
<ul>
<li><p>Two ways to pick up SSTables that will be compacted, the one is size compaction and the other is seek compaction, the db prefer size compaction than seek compaction.</p>
</li>
<li><p>Size compaction: firstly, select the level-L whose compaction score is not less than 1 and the largest among all levels, secondly, pick up the first SSTable whose file number is greater than the previous compacted SSTable’s in the selected level. wrap around to the first file in selected level if the previous compacted SSTable’s file number is the largest.</p>
</li>
<li><p>Invoke VersionSet::Finalize to compute the best compaction score.</p>
</li>
<li>Score of level-0 is the ratio betweens the number of file in level-0  and config::kL0_CompactionTrigger(default 4).</li>
<li>score of level-L ( 0 &lt; L &lt; config::kNumLevels-1) is ratio betweens the total bytes in level-L and 10**L MB.</li>
</ul>
<blockquote>
<pre><code>// db/version_set.cc-1055
void VersionSet::Finalize(Version* v) {
  // Precomputed best level for next compaction
  int best_level = -1;
  double best_score = -1;

  for (int level = 0; level &lt; config::kNumLevels-1; level++) {
    double score;
    if (level == 0) {
      // We treat level-0 specially by bounding the number of files
      // instead of number of bytes for two reasons:
      //
      // (1) With larger write-buffer sizes, it is nice not to do too
      // many level-0 compactions.
      //
      // (2) The files in level-0 are merged on every read and
      // therefore we wish to avoid too many files when the individual
      // file size is small (perhaps because of a small write-buffer
      // setting, or very high compression ratios, or lots of
      // overwrites/deletions).
      score = v-&gt;files_[level].size() /
          static_cast&lt;double&gt;(config::kL0_CompactionTrigger);
    } else {
      // Compute the ratio of current size to size limit.
      const uint64_t level_bytes = TotalFileSize(v-&gt;files_[level]);
      score = static_cast&lt;double&gt;(level_bytes) / MaxBytesForLevel(level);
    }

    if (score &gt; best_score) {
      best_level = level;
      best_score = score;
    }
  }

  v-&gt;compaction_level_ = best_level;
  v-&gt;compaction_score_ = best_score;
}



// db/version_set.cc-34
static double MaxBytesForLevel(int level) {
  // Note: the result for level zero is not really used since we set
  // the level-0 compaction threshold based on number of files.
  double result = 10 * 1048576.0;  // Result for both level-0 and level-1
  while (level &gt; 1) { 
    result *= 10;
    level--;
  }
  return result;
}
</code></pre></blockquote>
<ul>
<li><p>VersionSet::Finalize is called in VersionSet::Recovery and VersionSet::LogAndApply, i.e. compaction score is updated when MANIFEST file is updated.</p>
</li>
<li><p>seek compaction: pick the first SSTable whose allowd_seeks below zero.</p>
</li>
</ul>
<blockquote>
<pre><code>// db/version_set.cc-422
bool Version::UpdateStats(const GetStats&amp; stats) {
  FileMetaData* f = stats.seek_file;
  if (f != NULL) {
    f-&gt;allowed_seeks--;
    if (f-&gt;allowed_seeks &lt;= 0 &amp;&amp; file_to_compact_ == NULL) {
      file_to_compact_ = f; 
      file_to_compact_level_ = stats.seek_file_level;
      return true;
    } 
  }
  return false;
}
</code></pre></blockquote>
<ul>
<li><p>Version::UpdateStats is called in DBImpl::Read directly and  DBIter::Next indirectly. when you retrive Key-Value pair in SSTables and more than one SSTables are seeked, drop the allow_seeks of first shot-missing SSTable.</p>
</li>
<li><p>DBImpl::Get</p>
</li>
</ul>
<blockquote>
<pre><code>db/version_set.cc-384 Version::Get
db/db_impl.cc-1140 DBImpl::Get


// db/version_set.cc-384 Version::Get
      if (last_file_read != NULL &amp;&amp; stats-&gt;seek_file == NULL) {
        // We have had more than one seek for this read.  Charge the 1st file.
        stats-&gt;seek_file = last_file_read;
        stats-&gt;seek_file_level = last_file_read_level;
      }    
</code></pre></blockquote>
<ul>
<li>DBIter::Next</li>
</ul>
<blockquote>
<pre><code>db/version_set.cc-435 Version::RecordReadSample
db/db_impl.cc-1169 DBImpl::RecordReadSample
db/db_iter.cc-136 DBIter::ParseKey
db/db_iter.cc-179 DBIter::FindNextUserEntry
db/db_iter.cc-170 DBIter::Next


// db/version_set.cc-435 Version::RecordReadSample
bool Version::RecordReadSample(Slice internal_key) {
  ParsedInternalKey ikey;
  if (!ParseInternalKey(internal_key, &amp;ikey)) {
    return false;
  }

  struct State {
    GetStats stats;  // Holds first matching file
    int matches;

    static bool Match(void* arg, int level, FileMetaData* f) {
      State* state = reinterpret_cast&lt;State*&gt;(arg);
      state-&gt;matches++;
      if (state-&gt;matches == 1) {
        // Remember first match.
        state-&gt;stats.seek_file = f;
        state-&gt;stats.seek_file_level = level;
      }
      // We can stop iterating once we have a second match.
      return state-&gt;matches &lt; 2;
    }
  };

  State state;
  state.matches = 0;
  ForEachOverlapping(ikey.user_key, internal_key, &amp;state, &amp;State::Match);

  // Must have at least two matches since we want to merge across
  // files. But what if we have a single file that contains many
  // overwrites and deletions?  Should we have another mechanism for
  // finding such files?
  if (state.matches &gt;= 2) {
    // 1MB cost is about 1 seek (see comment in Builder::Apply).
    return UpdateStats(state.stats);
  }
  return false;
}
</code></pre></blockquote>
<ul>
<li>the allow_seeks is initialized as follows:</li>
</ul>
<blockquote>
<pre><code>// /db/verset_set.cc-680 VerionSet::Apply
      // We arrange to automatically compact this file after
      // a certain number of seeks.  Let&#39;s assume:
      //   (1) One seek costs 10ms
      //   (2) Writing or reading 1MB costs 10ms (100MB/s)
      //   (3) A compaction of 1MB does 25MB of IO:
      //         1MB read from this level
      //         10-12MB read from next level (boundaries may be misaligned)
      //         10-12MB written to next level
      // This implies that 25 seeks cost the same as the compaction
      // of 1MB of data.  I.e., one seek costs approximately the
      // same as the compaction of 40KB of data.  We are a little
      // conservative and allow approximately one seek for every 16KB
      // of data before triggering a compaction.
      f-&gt;allowed_seeks = (f-&gt;file_size / 16384);
      if (f-&gt;allowed_seeks &lt; 100) f-&gt;allowed_seeks = 100;

      levels_[level].deleted_files.erase(f-&gt;number);
      levels_[level].added_files-&gt;insert(f);
</code></pre></blockquote>
<p><strong>pick overlapped files</strong></p>
<p>For level-L compaction, we shall pick overlapped files in parent level (level-L+1);  then merge SSTables from level-L and level+1 and output new SSTables that will be added to level-L+1; finally, delete obsolete SSTables.</p>
<p><strong>Particularly, for level-0 compaction, we shall also pick other overlapped files in level-0</strong></p>
<blockquote>
<pre><code>// db/version_set.cc:1319 VersionSet::PickCompaction
  // Files in level 0 may overlap each other, so pick up all overlapping ones
  if (level == 0) { 
    InternalKey smallest, largest;
    GetRange(c-&gt;inputs_[0], &amp;smallest, &amp;largest);
    // Note that the next call will discard the file we placed in
    // c-&gt;inputs_[0] earlier and replace it with an overlapping set
    // which will include the picked file.
    current_-&gt;GetOverlappingInputs(0, &amp;smallest, &amp;largest, &amp;c-&gt;inputs_[0]);
    assert(!c-&gt;inputs_[0].empty());
  }
</code></pre></blockquote>
<p><strong>Then invoke VersionSet::SetupOtherInputs to pick overlapped files in level level-L+1</strong></p>
<blockquote>
<pre><code>// db/version_set.cc:1335 VersionSet::SetupOtherInputs
void VersionSet::SetupOtherInputs(Compaction* c) {
  const int level = c-&gt;level();
  InternalKey smallest, largest;
  GetRange(c-&gt;inputs_[0], &amp;smallest, &amp;largest);

  current_-&gt;GetOverlappingInputs(level+1, &amp;smallest, &amp;largest, &amp;c-&gt;inputs_[1]);

  // Get entire range covered by compaction
  InternalKey all_start, all_limit;
  GetRange2(c-&gt;inputs_[0], c-&gt;inputs_[1], &amp;all_start, &amp;all_limit);

  // See if we can grow the number of inputs in &quot;level&quot; without
  // changing the number of &quot;level+1&quot; files we pick up.
  if (!c-&gt;inputs_[1].empty()) {
    std::vector&lt;FileMetaData*&gt; expanded0;
    current_-&gt;GetOverlappingInputs(level, &amp;all_start, &amp;all_limit, &amp;expanded0);
    const int64_t inputs0_size = TotalFileSize(c-&gt;inputs_[0]);
    const int64_t inputs1_size = TotalFileSize(c-&gt;inputs_[1]);
    const int64_t expanded0_size = TotalFileSize(expanded0);
    if (expanded0.size() &gt; c-&gt;inputs_[0].size() &amp;&amp;
        inputs1_size + expanded0_size &lt; kExpandedCompactionByteSizeLimit) {
      InternalKey new_start, new_limit;
      GetRange(expanded0, &amp;new_start, &amp;new_limit);
      std::vector&lt;FileMetaData*&gt; expanded1;
      current_-&gt;GetOverlappingInputs(level+1, &amp;new_start, &amp;new_limit,
                                     &amp;expanded1);
      if (expanded1.size() == c-&gt;inputs_[1].size()) {
        Log(options_-&gt;info_log,
            &quot;Expanding@%d %d+%d (%ld+%ld bytes) to %d+%d (%ld+%ld bytes)\n&quot;,
            level,
            int(c-&gt;inputs_[0].size()),
            int(c-&gt;inputs_[1].size()),
            long(inputs0_size), long(inputs1_size),
            int(expanded0.size()),
            int(expanded1.size()),
            long(expanded0_size), long(inputs1_size));
        smallest = new_start;
        largest = new_limit;
        c-&gt;inputs_[0] = expanded0;
        c-&gt;inputs_[1] = expanded1;
        GetRange2(c-&gt;inputs_[0], c-&gt;inputs_[1], &amp;all_start, &amp;all_limit);
      }
    }
  }

  // Compute the set of grandparent files that overlap this compaction
  // (parent == level+1; grandparent == level+2)
  if (level + 2 &lt; config::kNumLevels) {
    current_-&gt;GetOverlappingInputs(level + 2, &amp;all_start, &amp;all_limit,
                                   &amp;c-&gt;grandparents_);
  }

  if (false) {
    Log(options_-&gt;info_log, &quot;Compacting %d &#39;%s&#39; .. &#39;%s&#39;&quot;,
        level,
        smallest.DebugString().c_str(),
        largest.DebugString().c_str());
  }

  // Update the place where we will do the next compaction for this level.
  // We update this immediately instead of waiting for the VersionEdit
  // to be applied so that if the compaction fails, we will try a different
  // key range next time.
  compact_pointer_[level] = largest.Encode().ToString();
  c-&gt;edit_.SetCompactPointer(level, largest);
}
</code></pre></blockquote>
<p><strong>Conclusion</strong></p>
<ul>
<li><strong>step1</strong>: pick up SSTables in level-L and denote these files as input0, input0 is not overlapped with other SSTables in level-L.</li>
<li><strong>step2</strong>: get the smallest and the largest keys on <code>input0</code>, denote these keys as <code>smallest</code> and <code>largest</code> respectively.</li>
<li><strong>step3</strong>: get all SSTables in level-L+1 that overlapped with <code>input0</code>, denotes these files as <code>input1</code>.</li>
<li><strong>step4</strong>: get the smallest and the largest keys of <code>input0</code> and <code>input1</code>, denote these keys as <code>all_start</code> and <code>all_limit</code> respectively.</li>
<li><strong>step5</strong>: if <code>input1</code> contains no files,then goto the step13.</li>
<li><strong>step6</strong>: get all SSTables in level-L that overlapped with key range(<code>all_start</code>, <code>all_limit</code>), denotes these files as <code>expand0</code>.</li>
<li><strong>step7</strong>: if the number of files in <code>expand0</code> is greater than that in <code>input0</code> and total bytes of <code>expand0</code> and <code>input1</code> are less than <code>kExpandedCompactionByteSizeLimit</code> (default 50MB), then try to grow up files in level-L, otherwise, go to the step13.</li>
<li><strong>step8</strong>: get the smallest and the largetst keys on <code>expand0</code>. denote these keys as <code>new_start</code> and <code>new_limit</code>.</li>
<li><strong>step9</strong>: get all SSTables in level-L+1 that overlapped with key range(<code>new_start</code>, <code>new_limit</code>), denotes these files as <code>expand1</code>.</li>
<li><strong>step10</strong>: if <code>expand1</code> has the as many files as <code>input1</code>, then assign <code>expand0</code>, <code>expand1</code>, <code>new_start</code> and <code>new_limit</code> to <code>input0</code>, <code>input1</code>, <code>smallest</code> and <code>largest</code> respectively. otherwise goto step13.</li>
<li><strong>step12</strong>:  update <code>all_start</code> and <code>all_limit</code> to the smallest and the largest keys of <code>input0</code> and <code>input1</code>.</li>
<li><strong>step13</strong>: if level-L+2 exists, then get files in level-L+2 that overlapped with key range(<code>all_start</code>, <code>all_limit</code>), denotes these files as <code>grandparents</code>.</li>
<li><strong>step14</strong>: update <code>compact_pointer</code> in level-L to <code>largest</code>.</li>
</ul>
<p><strong>Do compaction after pick up all input files</strong></p>
<p><strong>case 1: Move the single sstable from level-L to level-L+1 trivially</strong> iff <code>input0</code> contains only one file and <code>input1</code> contains none and total bytes of overlapped files in level-L+2  are less than  kMaxGrandParentOverlapBytes(default 20MB).</p>
<blockquote>
<pre><code>// db/version_set.cc-1455
bool Compaction::IsTrivialMove() const {
  // Avoid a move if there is lots of overlapping grandparent data.
  // Otherwise, the move could create a parent file that will require
  // a very expensive merge later on.
  return (num_input_files(0) == 1 &amp;&amp; 
          num_input_files(1) == 0 &amp;&amp; 
          TotalFileSize(grandparents_) &lt;= kMaxGrandParentOverlapBytes);
}


// db/db_impl.cc-716
} else if (!is_manual &amp;&amp; c-&gt;IsTrivialMove()) {
    // Move file to next level
    assert(c-&gt;num_input_files(0) == 1);
    FileMetaData* f = c-&gt;input(0, 0);
    c-&gt;edit()-&gt;DeleteFile(c-&gt;level(), f-&gt;number);
    c-&gt;edit()-&gt;AddFile(c-&gt;level() + 1, f-&gt;number, f-&gt;file_size,
                       f-&gt;smallest, f-&gt;largest);
    status = versions_-&gt;LogAndApply(c-&gt;edit(), &amp;mutex_);
    if (!status.ok()) {
      RecordBackgroundError(status);
    } 
    VersionSet::LevelSummaryStorage tmp; 
    Log(options_.info_log, &quot;Moved #%lld to level-%d %lld bytes %s: %s\n&quot;,
        static_cast&lt;unsigned long long&gt;(f-&gt;number),
        c-&gt;level() + 1, 
        static_cast&lt;unsigned long long&gt;(f-&gt;file_size),
        status.ToString().c_str(),
        versions_-&gt;LevelSummary(&amp;tmp)
</code></pre></blockquote>
<p><strong>case 2: Do a non-trivial compaction by DoCompactionWork function</strong></p>
<ul>
<li><p><strong>MakeInputIterator(db/db_impl.cc-908:DBImpl::DoCompactionWork)</strong>: make a MergingIterator from input files. create a TwoLevelIterator for each level-0 file, if any; create a TwoLevelIterator for concatenating all input files in the same level other than level-0. the former TwoLevelIterator consists of two Block::Iter instances, the one for the index block, the other for the data block. the latter TwoLevelIterator consists of one Version::LevelFileNumIterator instance for walking through file numbers  and one TwoLevelIterator instance for accessing  the SSTable specified by an certain file number.</p>
</li>
<li><p><strong>MergingIterator::Next</strong> return the Key&amp;Value pairs in ascending order of internal keys. The total order of internal keys is well-defined. Distinct user keys are sorted in lexicographical order, newer version(greater sequence number) comes before older version(less sequence number) for the same user key.</p>
</li>
<li><p><strong>Merging rules</strong>: A user key is stored in multi-version, i.e. A user key is mapped to multiple internal keys with distinct SNs(sequnece numbers). When do major compaction, internal keys corresponding to the same user key are merged in the way that old versions(with less SN) are droped and the newest one is retained, in order to eliminate duplicate user keys. However, for the sake of  snapshot consistency, the version newer than the oldest snapshot are never dropped; Among the versions older than the oldest snapshot, the most recent version is taken into consideration,  if it’s tagged as ‘kTypeValue’, then it’s kept and all other versions are droped, otherwise, all versions are dropped.</p>
</li>
</ul>
<p><strong>Demo</strong></p>
<blockquote>
<pre><code>leveldb::ReadOptions options;
string key=&quot;foobar&quot;;
string value1, value2;
options.snapshot = db-&gt;GetSnapshot();//SN=1000

// get key &quot;foobar&quot; for the first time.
db-&gt;Get(options, key, &amp;value1);

//...
//do some time-consuming work, during this time, major compaction is carried out. 
//...

// get key &quot;foobar&quot; for the second time.
db-&gt;Get(options, key, &amp;value2);
db-&gt;ReleaseSnapshot(options.snapshot);
</code></pre></blockquote>
<ul>
<li><strong>Before get the key “foobar” from snapshot(SN=1000) for the first time.</strong></li>
</ul>
<blockquote>
<table>
<thead>
<tr>
<th>key</th>
<th>tag</th>
<th>sequence</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td>“foobar”</td>
<td>kTypeDeletion</td>
<td>2017</td>
<td></td>
</tr>
<tr>
<td>“foobar”</td>
<td>kTypeValue</td>
<td>1993</td>
<td>“If you miss the train I’m on”</td>
</tr>
<tr>
<td>“foobar”</td>
<td>kTypeValue</td>
<td>1001</td>
<td>“You will know that I am gone”</td>
</tr>
<tr>
<td>“foobar”</td>
<td>kTypeValue</td>
<td>999</td>
<td>“You can hear the whistle blow a hundred miles”</td>
</tr>
<tr>
<td>“foobar”</td>
<td>kTypeDeletion</td>
<td>800</td>
<td></td>
</tr>
<tr>
<td>“foobar”</td>
<td>kTypeValue</td>
<td>200</td>
<td>“A hundred miles,a hundred miles”</td>
</tr>
</tbody>
</table>
</blockquote>
<ul>
<li><p><strong>Then retrieve the value “You can hear the whistle blow a hundred miles” by the key “foobar”.</strong></p>
</li>
<li><p><strong>During this time, major compaction is carried out.</strong></p>
</li>
</ul>
<blockquote>
<table>
<thead>
<tr>
<th>key</th>
<th>tag</th>
<th>sequence</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td>“foobar”</td>
<td>kTypeDeletion</td>
<td>2017</td>
<td></td>
</tr>
<tr>
<td>“foobar”</td>
<td>kTypeValue</td>
<td>1993</td>
<td>“If you miss the train I’m on”</td>
</tr>
<tr>
<td>“foobar”</td>
<td>kTypeValue</td>
<td>1001</td>
<td>“You will know that I am gone”</td>
</tr>
<tr>
<td>“foobar”</td>
<td>kTypeValue</td>
<td>999</td>
<td>“You can hear the whistle blow a hundred miles”</td>
</tr>
</tbody>
</table>
</blockquote>
<ul>
<li><strong>At last, get the key “foobar” for the second time, retrieve the same value.</strong></li>
</ul>
<p><strong>Switch output files</strong></p>
<ul>
<li><strong>case1</strong>: The current output file has overlapped too many files in the grandparent level, the total bytes of overlapped files in the grandparent level reach kMaxGrandParentOverlapBytes(20MB).</li>
</ul>
<blockquote>
<pre><code>db/version_set.cc-1493
bool Compaction::ShouldStopBefore(const Slice&amp; internal_key) {
  // Scan to find earliest grandparent file that contains key.
  const InternalKeyComparator* icmp = &amp;input_version_-&gt;vset_-&gt;icmp_;
  while (grandparent_index_ &lt; grandparents_.size() &amp;&amp;
      icmp-&gt;Compare(internal_key,
                    grandparents_[grandparent_index_]-&gt;largest.Encode()) &gt; 0) { 
    if (seen_key_) {
      overlapped_bytes_ += grandparents_[grandparent_index_]-&gt;file_size;
    }    
    grandparent_index_++;
  }
  seen_key_ = true;

  if (overlapped_bytes_ &gt; kMaxGrandParentOverlapBytes) {
    // Too much overlap for current output; start new output
    overlapped_bytes_ = 0; 
    return true;
  } else {
    return false;
  }
}
</code></pre></blockquote>
<ul>
<li><strong>case2</strong>: The current file size is large enough(2MB).    </li>
</ul>
<blockquote>
<pre><code>// db/db_impl.cc-996: DoCompactionWork
// Close output file if it is big enough
      if (compact-&gt;builder-&gt;FileSize() &gt;=
          compact-&gt;compaction-&gt;MaxOutputFileSize()) {
        status = FinishCompactionOutputFile(compact, input);
        if (!status.ok()) {
          break;
        }
      }

// table/table_builder.cc-266
uint64_t TableBuilder::FileSize() const {
  return rep_-&gt;offset;
}

// db/version_set.h-342
// Maximum size of files to build during this compaction.
uint64_t MaxOutputFileSize() const { return max_output_file_size_; }

// db/version_set.cc-1437
Compaction::Compaction(int level)
    : level_(level),
      max_output_file_size_(MaxFileSizeForLevel(level)),
      input_version_(NULL),
      grandparent_index_(0),
      seen_key_(false),
      overlapped_bytes_(0) {
  for (int i = 0; i &lt; config::kNumLevels; i++) {
    level_ptrs_[i] = 0; 
  }
}

// db/version_set.cc-45
static uint64_t MaxFileSizeForLevel(int level) {
  return kTargetFileSize;  // We could vary per level to reduce number of files?
}
</code></pre></blockquote>
<p><strong>Attempt to do minor compaction during major compaction</strong></p>
<blockquote>
<pre><code>// db/db_impl.cc-915: DoCompactionWork
  for (; input-&gt;Valid() &amp;&amp; !shutting_down_.Acquire_Load(); ) {
    // Prioritize immutable compaction work
    if (has_imm_.NoBarrier_Load() != NULL) {
      const uint64_t imm_start = env_-&gt;NowMicros();
      mutex_.Lock();
      if (imm_ != NULL) {
        CompactMemTable();
        bg_cv_.SignalAll();  // Wakeup MakeRoomForWrite() if necessary
      }
      mutex_.Unlock();
      imm_micros += (env_-&gt;NowMicros() - imm_start);
    }
</code></pre></blockquote>
<hr>
<h3 id="3-Read"><a href="#3-Read" class="headerlink" title="3.Read"></a>3.Read</h3><h4 id="3-1-Get-operation-Get-a-single-Key-Value"><a href="#3-1-Get-operation-Get-a-single-Key-Value" class="headerlink" title="3.1 Get operation: Get a single Key-Value"></a>3.1 Get operation: Get a single Key-Value</h4><p><strong>data flow</strong></p>
<ul>
<li><strong>step1</strong>: Decide which version the specified key will be retrieved from.</li>
</ul>
<blockquote>
<pre><code>// db/db_impl.cc-1108
Status DBImpl::Get(const ReadOptions&amp; options,
                   const Slice&amp; key,
                   std::string* value) {
  Status s;
  MutexLock l(&amp;mutex_);
  SequenceNumber snapshot;
  if (options.snapshot != NULL) {
    snapshot = reinterpret_cast&lt;const SnapshotImpl*&gt;(options.snapshot)-&gt;number_;
  } else {
    snapshot = versions_-&gt;LastSequence();
  }
</code></pre></blockquote>
<ul>
<li><strong>step2</strong>: Increase refcounts of active MemTable, immutable MemTable and current Version.</li>
</ul>
<blockquote>
<pre><code>// db/db_impl.cc-1120
  MemTable* mem = mem_;
  MemTable* imm = imm_;
  Version* current = versions_-&gt;current();
  mem-&gt;Ref();
  if (imm != NULL) imm-&gt;Ref();
  current-&gt;Ref();

  bool have_stat_update = false;
  Version::GetStats stats;

  // Unlock while reading from files and memtables
</code></pre></blockquote>
<ul>
<li><strong>step3</strong>: First of all, atempt to retrieve the KeyValue from the active MemTable, goto step7 on success, fallthrough on failure.</li>
</ul>
<blockquote>
<pre><code>// db/db_impl.cc-1131
  {
    mutex_.Unlock();
    // First look in the memtable, then in the immutable memtable (if any).
    LookupKey lkey(key, snapshot);
    if (mem-&gt;Get(lkey, value, &amp;s)) {
      // Done
</code></pre></blockquote>
<ul>
<li><strong>step4</strong>:Then, attempt to retrieve the KeyValue from the immutable MemTable, goto step7 on success, fallthrough on failure.</li>
</ul>
<blockquote>
<pre><code>// db/db_impl.cc-1137
    } else if (imm != NULL &amp;&amp; imm-&gt;Get(lkey, value, &amp;s)) {
      // Done
</code></pre></blockquote>
<ul>
<li><strong>step5</strong>: Finally, attempt to retrieve the KeyValue from SSTables.</li>
</ul>
<blockquote>
<pre><code>// db/db_impl.cc-1139
    } else {
      s = current-&gt;Get(options, lkey, value, &amp;stats);
      have_stat_update = true;
    }
    mutex_.Lock();
  }
</code></pre></blockquote>
<ul>
<li><strong>step6</strong>: Trigger seek compaction if more than one SSTables are seeked and the allowed seek times of the 1st seeked SStable has dropped to zero.</li>
</ul>
<blockquote>
<pre><code>// db/db_impl.cc-1146
  if (have_stat_update &amp;&amp; current-&gt;UpdateStats(stats)) {
    MaybeScheduleCompaction();
  }
</code></pre></blockquote>
<ul>
<li><strong>step7</strong>: Decrease refcounts of active MemTable, immutable MemTable and current Version.</li>
</ul>
<blockquote>
<pre><code>// db/db_impl.cc-1149
  mem-&gt;Unref();
  if (imm != NULL) imm-&gt;Unref();
  current-&gt;Unref();
  return s;
}
</code></pre></blockquote>
<p><strong>key points</strong></p>
<ul>
<li>Multiple readers and one writer are allowed to access the same MemTable concurrently without holding mutex, instead, memory barrier(<code>port/atomic_pointer.h</code>) is used.</li>
<li>Multiple readers and background compaction thread are allowed to access the same SSTable without holding mutex.</li>
<li>Reference counting is employed to prevent immutable data structure from being removed accidently.</li>
<li>The mutex must be holden merely when operations alter the reference count.</li>
<li>Although the data structure are protected by reference count, however, they could be leaked if the reference count is nonzero and referenced by no pointers.</li>
</ul>
<p><strong>Get KeyValue from SSTables</strong></p>
<ul>
<li><code>db/version_set.cc:323 Get</code></li>
<li>Seek SStables in level-0, then in level-1, level-2, … until find out the specified key or all levels are searched.</li>
<li>SSTables of level-0 maybe overlap each other, so search the SSTables whose key range contains the specified key.</li>
<li>For level-2~L, SSTables in each level have non-overlapped key ranges, therefore, zero or one SSTable are searched in each level.</li>
<li>Load the SSTables’ data block that contains the specified key potentially into block cache, then look up in the block cache.</li>
</ul>
<p><strong>Address KeyValue by key</strong></p>
<ul>
<li>VersionSet.current_ points to the current Version.</li>
<li>Version.files_: <code>db/version_set.h-138 std::vector&lt;FileMetaData*&gt; files_[config::kNumLevels];</code></li>
<li>Each level has a entry that contains FileMetaData objects representing SSTables owned by this level in Version.files_.</li>
<li>FileMetaData:</li>
</ul>
<blockquote>
<pre><code>// db/version_edit.h-17
struct FileMetaData {
  int refs;
  int allowed_seeks;          // Seeks allowed until     compaction
  uint64_t number;
  uint64_t file_size;         // File size in bytes
  InternalKey smallest;       // Smallest internal key served by table
  InternalKey largest;        // Largest internal key served by table

  FileMetaData() : refs(0), allowed_seeks(1 &lt;&lt; 30), file_size(0) { }
};
</code></pre></blockquote>
<ul>
<li>select FileMetaData whose key range(smallest, largest) contains the key.</li>
<li>FileMetaData.number can be converted into the corresponding filename.</li>
</ul>
<blockquote>
<pre><code>// db/filename.cc-32
std::string TableFileName(const std::string&amp; name, uint64_t number) {
  assert(number &gt; 0); 
  return MakeFileName(name, number, &quot;ldb&quot;);
}

// db/filename.cc:32
static std::string MakeFileName(const std::string&amp; name, uint64_t number,
                                const char* suffix) {
  char buf[100];
  snprintf(buf, sizeof(buf), &quot;/%06llu.%s&quot;,
           static_cast&lt;unsigned long long&gt;(number),
           suffix);
  return name + buf;
}
</code></pre></blockquote>
<ul>
<li>TableCache (LRU algorithm) is used to control the maximum size of working set of opened files.</li>
<li>Bloom filter is used to filter impossible sstables out if enabled.</li>
<li>Block cache is used to load working set of data blocks.</li>
</ul>
<p><strong>LRU Cache</strong></p>
<p><img src="leveldb_images/leveldb_lrucache.png" alt="image"></p>
<ul>
<li>A LRU Cache is composed of a hash map(unordered_map in C++) and a list. </li>
<li>Hash tables in leveldb is faster than g++ builtin hashtable</li>
</ul>
<blockquote>
<pre><code>// util/cache.cc-66
// We provide our own simple hash table since it removes a whole bunch
// of porting hacks and is also faster than some of the built-in hash
// table implementations in some of the compiler/runtime combinations
// we have tested.  E.g., readrandom speeds up by ~5% over the g++
// 4.4.3&#39;s builtin hashtable.
</code></pre></blockquote>
<ul>
<li>Source files</li>
</ul>
<blockquote>
<pre><code>include/leveldb/cache.h
util/cache.cc
</code></pre></blockquote>
<ul>
<li>The LRUCache is general-purpose cache, both actual types of the key and the value depend on upper layer users.</li>
<li>When LRU Cache has no spare space to hold a new entry, the least recently used entry must be swapped out, users should provide deletion function for finalization, e.g. when a cache that manages opened fds discards an old fd to make room for a new fd,  the old fd shoud be closed.</li>
<li>Both table cache and block cache are ShardedLRUCaches that have 16 LRUCaches  stored in an array.  the insertion operations work as follows:</li>
</ul>
<p>&gt;</p>
<ul>
<li><strong>step1</strong>: Convert the key into uint32 by the hash function.</li>
<li><strong>step2</strong>: Use highest 4 bits to index LRUCache array whose size is 16.</li>
<li><strong>step3</strong>: Insert a entry into the chosen LRUCache. </li>
</ul>
<p><strong>TableCache</strong></p>
<ul>
<li>TableCache is globally unique and shared.</li>
</ul>
<blockquote>
<pre><code>// db/db_impl.cc-116 DBImpl
  table_cache_ = new TableCache(dbname_, &amp;options_, table_cache_size);

  versions_ = new VersionSet(dbname_, &amp;options_, table_cache_,
                         &amp;internal_comparator_);
</code></pre></blockquote>
<ul>
<li>Source files</li>
</ul>
<blockquote>
<pre><code>db/table_cache.h
db/table_cache.cc
</code></pre></blockquote>
<ul>
<li><strong>key</strong>: file numbers corresponding to SSTables.</li>
<li><strong>value</strong>: TableAndFile objects.</li>
</ul>
<blockquote>
<pre><code>// db/table_cache.cc-14
struct TableAndFile {
  RandomAccessFile* file;
  Table* table;
};
</code></pre></blockquote>
<ul>
<li><strong>deletion function</strong>: DeleteEntry</li>
</ul>
<blockquote>
<pre><code>// db/table_cache.cc-19
static void DeleteEntry(const Slice&amp; key, void* value) {
  TableAndFile* tf = reinterpret_cast&lt;TableAndFile*&gt;(value);
  delete tf-&gt;table;
  delete tf-&gt;file;
  delete tf;
}
</code></pre></blockquote>
<ul>
<li>Table is an in-core readonly SSTable, and TableBuilder is an in-core writable SSTable.</li>
<li>TableCache invokes FindTable function to fetch target Table.<code>db/table_cache.cc-45</code></li>
<li>Table invokes Open function to load index block and filter block. <code>table/table.cc-38</code></li>
</ul>
<p><strong>Block Cache</strong></p>
<ul>
<li>There is only one shared block cache in global.</li>
</ul>
<blockquote>
<pre><code>// db/db_impl.cc-98 Options
  // Control over blocks (user data is stored in a set of blocks, and
  // a block is the unit of reading from disk).

  // If non-NULL, use the specified cache for blocks.
  // If NULL, leveldb will automatically create and use an 8MB internal cache.
  // Default: NULL
  Cache* block_cache;
</code></pre></blockquote>
<ul>
<li><strong>key</strong>: 16B, consists of cache_id of the table and offset of the block.</li>
</ul>
<blockquote>
<pre><code>// table/table.cc-79 Table::Open
    rep-&gt;cache_id = (options.block_cache ? options.block_cache-&gt;NewId() : 0);

// table/table.cc:182 BlockReader
      char cache_key_buffer[16];
      EncodeFixed64(cache_key_buffer, table-&gt;rep_-&gt;cache_id);
      EncodeFixed64(cache_key_buffer+8, handle.offset());
      Slice key(cache_key_buffer, sizeof(cache_key_buffer));
</code></pre></blockquote>
<ul>
<li><p><strong>value</strong>: Block <code>table/block.cc</code></p>
</li>
<li><p><strong>deletion function</strong>: DeleteCachedBlock</p>
</li>
</ul>
<blockquote>
<pre><code>// table/table.cc:151
static void DeleteCachedBlock(const Slice&amp; key, void* value) {
  Block* block = reinterpret_cast&lt;Block*&gt;(value);
  delete block;
}
</code></pre></blockquote>
<p><strong>TableCache::Get</strong></p>
<ul>
<li>Load the table specified by <code>file_number</code> into cache</li>
<li>Then, invoke InternalGet to retrieve the target KeyValue</li>
</ul>
<blockquote>
<pre><code>// db/table_cache.cc-105
Status TableCache::Get(const ReadOptions&amp; options,
                       uint64_t file_number,
                       uint64_t file_size,
                       const Slice&amp; k,
                       void* arg,
                       void (*saver)(void*, const Slice&amp;, const Slice&amp;)) {
  Cache::Handle* handle = NULL;
  Status s = FindTable(file_number, file_size, &amp;handle);
  if (s.ok()) {
    Table* t = reinterpret_cast&lt;TableAndFile*&gt;(cache_-&gt;Value(handle))-&gt;table;
    s = t-&gt;InternalGet(options, k, arg, saver);
    cache_-&gt;Release(handle);
  }
  return s;
}
</code></pre></blockquote>
<p><strong>Table::InternalGet</strong></p>
<ul>
<li>First, search the key in <code>index block</code> and retrieve the BlockHandle of the target block.</li>
<li>Then, abandon searching if the key not match with the filter.</li>
<li>Finally, search the key in <code>data block</code>. </li>
</ul>
<blockquote>
<pre><code>// table/table.cc-226
Status Table::InternalGet(const ReadOptions&amp; options, const Slice&amp; k,
                          void* arg,
                          void (*saver)(void*, const Slice&amp;, const Slice&amp;)) {
  Status s;
  Iterator* iiter = rep_-&gt;index_block-&gt;NewIterator(rep_-&gt;options.comparator);
  iiter-&gt;Seek(k);
  if (iiter-&gt;Valid()) {
    Slice handle_value = iiter-&gt;value();
    FilterBlockReader* filter = rep_-&gt;filter;
    BlockHandle handle;
    if (filter != NULL &amp;&amp;
        handle.DecodeFrom(&amp;handle_value).ok() &amp;&amp;
        !filter-&gt;KeyMayMatch(handle.offset(), k)) {
      // Not found
    } else {
      Iterator* block_iter = BlockReader(this, options, iiter-&gt;value());
      block_iter-&gt;Seek(k);
      if (block_iter-&gt;Valid()) {
        (*saver)(arg, block_iter-&gt;key(), block_iter-&gt;value());
      }
      s = block_iter-&gt;status();
      delete block_iter;
    }
  }
  if (s.ok()) {
    s = iiter-&gt;status();
  }
  delete iiter;
  return s;
}
</code></pre></blockquote>
<p><strong>How to search key in data/index blocks?</strong></p>
<ul>
<li>Block::Iter::Seek</li>
<li>binary search the restart interval which contains the key potentially.</li>
<li>linear search the key in the target restart interval.</li>
</ul>
<blockquote>
<pre><code>table/block.cc-165
  virtual void Seek(const Slice&amp; target) {
    // Binary search in restart array to find the last restart point
    // with a key &lt; target
    uint32_t left = 0;
    uint32_t right = num_restarts_ - 1;
    while (left &lt; right) {
      uint32_t mid = (left + right + 1) / 2;
      uint32_t region_offset = GetRestartPoint(mid);
      uint32_t shared, non_shared, value_length;
      const char* key_ptr = DecodeEntry(data_ + region_offset,
                                        data_ + restarts_,
                                        &amp;shared, &amp;non_shared, &amp;value_length);
      if (key_ptr == NULL || (shared != 0)) {
        CorruptionError();
        return;
      }
      Slice mid_key(key_ptr, non_shared);
      if (Compare(mid_key, target) &lt; 0) {
        // Key at &quot;mid&quot; is smaller than &quot;target&quot;.  Therefore all
        // blocks before &quot;mid&quot; are uninteresting.
        left = mid;
      } else {
        // Key at &quot;mid&quot; is &gt;= &quot;target&quot;.  Therefore all blocks at or
        // after &quot;mid&quot; are uninteresting.
        right = mid - 1;
      }
    }

    // Linear search (within restart block) for first key &gt;= target
    SeekToRestartPoint(left);
    while (true) {
      if (!ParseNextKey()) {
        return;
      }
      if (Compare(key_, target) &gt;= 0) {
        return;
      }
    }
  }
</code></pre></blockquote>
<ul>
<li>ParseNextKey:</li>
</ul>
<blockquote>
<pre><code>// table/block.cc-226
  bool ParseNextKey() {
    current_ = NextEntryOffset();
    const char* p = data_ + current_;
    const char* limit = data_ + restarts_;  // Restarts come right after data
    if (p &gt;= limit) {
      // No more entries to return.  Mark as invalid.
      current_ = restarts_;
      restart_index_ = num_restarts_;
      return false;
    }

    // Decode next entry
    uint32_t shared, non_shared, value_length;
    p = DecodeEntry(p, limit, &amp;shared, &amp;non_shared, &amp;value_length);
    if (p == NULL || key_.size() &lt; shared) {
      CorruptionError();
      return false;
    } else {
      key_.resize(shared);
      key_.append(p, non_shared);
      value_ = Slice(p + non_shared, value_length);
      while (restart_index_ + 1 &lt; num_restarts_ &amp;&amp;
             GetRestartPoint(restart_index_ + 1) &lt; current_) {
        ++restart_index_;
      }
      return true;
    }
  }
};
</code></pre></blockquote>
<h4 id="3-2-NewIterator-Scan-a-batch-of-Key-Values"><a href="#3-2-NewIterator-Scan-a-batch-of-Key-Values" class="headerlink" title="3.2 NewIterator: Scan a batch of Key-Values"></a>3.2 NewIterator: Scan a batch of Key-Values</h4><p><strong>Composite pattern</strong></p>
<pre><code>Allows you to compose objects into tree structures to represent part-whole hierarchies. Composite pattern lets clients treat individual objects and compositions of objects uniformly. 
- Design Pattern:Elements of Reuseable Object-Oriented Software.
</code></pre><p><strong>Algebraic data type</strong></p>
<pre><code>In computer programming, especially functional programming and type theory, an algebraic data type is a kind of composite type, i.e., a type formed by combining other types.
- https://en.wikipedia.org/wiki/Algebraic_data_type.
</code></pre><p>Iterator hierarchy conforms to composite pattern, the iterator is an example of algebraic data type.</p>
<p><strong>Iterator hierarchy</strong></p>
<ul>
<li><strong>Base iterator</strong></li>
</ul>
<blockquote>
<pre><code>include/leveldb/iterator.h-23
</code></pre></blockquote>
<p><img src="leveldb_images/leveldb_iterator.png" alt="image"></p>
<ul>
<li><strong>simple iterator</strong></li>
</ul>
<blockquote>
<p><strong>MemTableIterator</strong></p>
<ul>
<li>for iterating MemTable</li>
</ul>
<pre><code>db/memtable.cc-51
</code></pre><p><strong>Block::Iter</strong></p>
<ul>
<li>for iterating both data block and index block</li>
</ul>
<pre><code>table/block.cc-76
</code></pre></blockquote>
<ul>
<li><strong>complex iterator</strong></li>
</ul>
<blockquote>
<p><strong>TwoLevelIterator</strong></p>
<ul>
<li>for iterating an in-core SSTable</li>
<li>a TwoLevelIterator iterator is composed of 2 Block::Iter objects, one for iterating the index block, the other one for iterating the data block. </li>
</ul>
<pre><code>table/two_level_iterator.cc-18
</code></pre></blockquote>
<p><strong>MergingIterator</strong></p>
<blockquote>
<ul>
<li>for iterating internal keys in ascendent order.</li>
<li>a MergingIterator is composed of Iterators.</li>
<li>MergingIterator merges all of its child iterator as its own result.</li>
</ul>
<pre><code>// table/merger.cc-35
  virtual void SeekToFirst() {
    for (int i = 0; i &lt; n_; i++) {
      children_[i].SeekToFirst();
    }
    FindSmallest();
    direction_ = kForward;
  }


// table/merger.cc-59
  virtual void Next() {
    assert(Valid());

    // Ensure that all children are positioned after key().
    // If we are moving in the forward direction, it is already
    // true for all of the non-current_ children since current_ is
    // the smallest child and key() == current_-&gt;key().  Otherwise,
    // we explicitly position the non-current_ children.
    if (direction_ != kForward) {
      for (int i = 0; i &lt; n_; i++) {
        IteratorWrapper* child = &amp;children_[i];
        if (child != current_) {
          child-&gt;Seek(key());
          if (child-&gt;Valid() &amp;&amp;
              comparator_-&gt;Compare(key(), child-&gt;key()) == 0) {
            child-&gt;Next();
          }
        }
      }
      direction_ = kForward;
    }

    current_-&gt;Next();
    FindSmallest();
  }
</code></pre></blockquote>
<ul>
<li>all child seek to first key, and find the smallest key as the first key of MergingIterator.</li>
<li>for Next invocation, move the current child iterator who has the smallest key forward, then find the next smallet key among all child iterators.</li>
</ul>
<p><strong>DBIter</strong></p>
<ul>
<li>for iterating user keys of the db in lexicograhical order, in contrast to MergingIterator which iterates internal keys.</li>
<li>DBIter invokes FindNextUserEntry skip deletion marker.</li>
</ul>
<blockquote>
<pre><code>// db/db_iter.cc-146
void DBIter::Next() {
  assert(valid_);

  if (direction_ == kReverse) {  // Switch directions?
    direction_ = kForward;
    // iter_ is pointing just before the entries for this-&gt;key(),
    // so advance into the range of entries for this-&gt;key() and then
    // use the normal skipping code below.
    if (!iter_-&gt;Valid()) {
      iter_-&gt;SeekToFirst();
    } else {
      iter_-&gt;Next();
    }
    if (!iter_-&gt;Valid()) {
      valid_ = false;
      saved_key_.clear();
      return;
    }
    // saved_key_ already contains the key to skip past.
  } else {
    // Store in saved_key_ the current key so we skip it below.
    SaveKey(ExtractUserKey(iter_-&gt;key()), &amp;saved_key_);
  }

  FindNextUserEntry(true, &amp;saved_key_);
}

// db/db_iter.cc-173
void DBIter::FindNextUserEntry(bool skipping, std::string* skip) {
  // Loop until we hit an acceptable entry to yield
  assert(iter_-&gt;Valid());
  assert(direction_ == kForward);
  do {
    ParsedInternalKey ikey;
    if (ParseKey(&amp;ikey) &amp;&amp; ikey.sequence &lt;= sequence_) {
      switch (ikey.type) {
        case kTypeDeletion:
          // Arrange to skip all upcoming entries for this key since
          // they are hidden by this deletion.
          SaveKey(ikey.user_key, skip);
          skipping = true;
          break;
        case kTypeValue:
          if (skipping &amp;&amp;
              user_comparator_-&gt;Compare(ikey.user_key, *skip) &lt;= 0) {
            // Entry hidden
          } else {
            valid_ = true;
            saved_key_.clear();
            return;
          }
          break;
      }
    }
    iter_-&gt;Next();
  } while (iter_-&gt;Valid());
  saved_key_.clear();
  valid_ = false;
}
</code></pre></blockquote>
<ul>
<li>call RecordReadSample to trigger Compaction in every data retrieval of randomized size ranging from 0 to 2 MB.</li>
</ul>
<blockquote>
<pre><code>// db/db_iter.cc-130
inline bool DBIter::ParseKey(ParsedInternalKey* ikey) {
  Slice k = iter_-&gt;key();
  ssize_t n = k.size() + iter_-&gt;value().size();
  bytes_counter_ -= n;
  while (bytes_counter_ &lt; 0) {
    bytes_counter_ += RandomPeriod();
    db_-&gt;RecordReadSample(k);
  }
  if (!ParseInternalKey(k, ikey)) {
    status_ = Status::Corruption(&quot;corrupted internal key in DBIter&quot;);
    return false;
  } else {
    return true;
  }
}


// db/db_iter.cc-1176
void DBImpl::RecordReadSample(Slice key) {
  MutexLock l(&amp;mutex_);
  if (versions_-&gt;current()-&gt;RecordReadSample(key)) {
    MaybeScheduleCompaction();
  }
}
</code></pre></blockquote>
<hr>
<h2 id="Open"><a href="#Open" class="headerlink" title="Open"></a>Open</h2><h3 id="DB-is-opened-in-3-situations"><a href="#DB-is-opened-in-3-situations" class="headerlink" title="DB is opened in 3 situations"></a>DB is opened in 3 situations</h3><ol>
<li>create a new empty db.</li>
<li>Reopen a db that has terminates gracefully.</li>
<li>Recover a db to a consistency state from its last crash.</li>
</ol>
<h3 id="DB-Open-demo"><a href="#DB-Open-demo" class="headerlink" title="DB::Open demo"></a>DB::Open demo</h3><blockquote>
<pre><code>#include &lt;cassert&gt;
#include &quot;leveldb/db.h&quot;

leveldb::DB* db;
leveldb::Options options;
options.create_if_missing = true;
leveldb::Status status = leveldb::DB::Open(options, &quot;/tmp/testdb&quot;, &amp;db);
assert(status.ok())
</code></pre></blockquote>
<h3 id="Customize-DB-by-configuring-leveldb-Options"><a href="#Customize-DB-by-configuring-leveldb-Options" class="headerlink" title="Customize DB by configuring leveldb::Options"></a>Customize DB by configuring leveldb::Options</h3><p><code>include/leveldb/options.h</code></p>
<p><img src="leveldb_images/leveldb_options.png" alt="image"></p>
<blockquote>
<ul>
<li><strong><code>comparator</code></strong>: (default: bytewise comparator, lexicographical order)<br>user-defined function for comparing user keys.</li>
<li><strong><code>create_if_missing</code></strong>: (default: false)<br>similar to  O_CREAT for syscall open</li>
<li><strong><code>error_if_exists</code></strong>: (false)<br>smilar to O_EXCL|O_CREAT for syscall open</li>
<li><strong><code>paranoid_checks</code></strong>: (false)<br>do aggressive checking, failing to read block if crc checksum is mismatching. </li>
<li><strong><code>env</code></strong>: (Env::Default(), PosixEnv)<br>encapsulate syscalls in different platforms, bridge design pattern, use PosixEnv in Linux, high portability.</li>
<li><strong><code>info_log</code></strong>: (NULL)<br>basedir/LOG, runtime trace info, not WAL.</li>
<li><strong><code>write_buffer_size</code></strong>:  (4MB)<br>maximum size in bytes of mem_(MemTable), switch/rollup/cut WAL log when the size of MemTable approximates to write_buffer_size.</li>
<li><strong><code>max_open_files</code></strong>: (1000)<br>limit number of opened files.</li>
</ul>
<p><strong>table_cache [db/db_impl.cc:139:DBImpl]</strong></p>
<pre><code>    // db/db_impl.cc-139:DBImpl
      // Reserve ten files or so for other uses and give the rest to TableCache.
      const int table_cache_size = options_.max_open_files - kNumNonTableCacheFiles;
      table_cache_ = new TableCache(dbname_, &amp;options_, table_cache_size);
</code></pre><ul>
<li><strong><code>block_cache</code></strong>: (NULL)<br>block is unit of reading from disk, block_cache keep working set of blocks. user-specified</li>
</ul>
<p><strong>e.g.</strong></p>
<pre><code>  #include &quot;leveldb/cache.h&quot;

  leveldb::Options options;
  options.cache = leveldb::NewLRUCache(100 * 1048576);  // 100MB cache
  leveldb::DB* db;
  leveldb::DB::Open(options, name, &amp;db);
  ... use the db ...
  delete db
  delete options.cache;
</code></pre><ul>
<li><strong>block_size</strong>: (4KB)<br>maximum size of data block, switch a new one if the data block approximates to block_size.</li>
<li><strong>block_restart_interval</strong>: (16)<br>Number of keys between restart points for delta encoding of keys. data_block/index_block is split into several block_interval in every <code>block_restart_interval</code> keys.</li>
<li><strong>compression</strong>: (kSnappyCompression)<br>compress block. kNoCompression(0x0)|kNoCompression(0x1). ~On a single core of a Core i7 processor in 64-bit mode, it compresses at about <code>250 MB/sec</code> or more and decompresses at about <code>500 MB/sec</code> or more. Typical compression ratios (based on the benchmark suite) are about 1.5-1.7x for plain text, about 2-4x for HTML, and of course 1.0x for JPEGs, PNGs and other already-compressed data. Similar numbers for zlib in its fastest mode are 2.6-2.8x, 3-7x and 1.0x, respectively.~ refer to <a href="https://github.com/google/snappy/blob/master/README" target="_blank" rel="external">https://github.com/google/snappy/blob/master/README</a></li>
</ul>
<ul>
<li><strong>reuse_logs</strong>: (false), EXPERIMENTAL<br>reuse existing log/MANIFEST files when re-opening a database.</li>
</ul>
<ul>
<li><strong>filter_policy</strong>: (NULL)</li>
</ul>
<p><strong>e.g</strong></p>
<pre><code>   leveldb::Options options;
   options.filter_policy = NewBloomFilterPolicy(10);
   leveldb::DB* db;
   leveldb::DB::Open(options, &quot;/tmp/testdb&quot;, &amp;db);
   ... use the database ...
   delete db;
   delete options.filter_policy;
</code></pre></blockquote>
<h3 id="Implementation-of-DB-Open"><a href="#Implementation-of-DB-Open" class="headerlink" title="Implementation of DB::Open"></a>Implementation of DB::Open</h3><h4 id="step1-instantiate-a-DBImpl-object"><a href="#step1-instantiate-a-DBImpl-object" class="headerlink" title="step1: instantiate a DBImpl object"></a>step1: instantiate a DBImpl object</h4><blockquote>
<pre><code>//db/db_impl.cc-1493 DB::Open
  DBImpl* impl = new DBImpl(options, dbname);
</code></pre></blockquote>
<p>configure fields of DBImpl and create an empty objects of TableCache and VersionSet.</p>
<h4 id="step2-create-db-data-directory-and-require-file-lock-on-LOCK-file"><a href="#step2-create-db-data-directory-and-require-file-lock-on-LOCK-file" class="headerlink" title="step2: create db data directory and require file lock on LOCK file."></a>step2: create db data directory and require file lock on LOCK file.</h4><blockquote>
<pre><code>    // db/db_impl.cc-276 DBImpl::Recover
      env_-&gt;CreateDir(dbname_);
      assert(db_lock_ == NULL);
      Status s = env_-&gt;LockFile(LockFileName(dbname_), &amp;db_lock_);
      if (!s.ok()) {
        return s;
      }
</code></pre></blockquote>
<h4 id="step3-return-on-error-in-two-cases-1-no-CURRENT-file-exists-but-create-if-missing-flag-is-off-2-CURRENT-file-exists-but-error-if-exists-flag-is-on-fallthrough-on-success"><a href="#step3-return-on-error-in-two-cases-1-no-CURRENT-file-exists-but-create-if-missing-flag-is-off-2-CURRENT-file-exists-but-error-if-exists-flag-is-on-fallthrough-on-success" class="headerlink" title="step3: return on error in two cases: 1. no CURRENT file exists but create_if_missing flag is off, 2. CURRENT file exists but error_if_exists flag is on. fallthrough on success."></a>step3: return on error in two cases: 1. no CURRENT file exists but create_if_missing flag is off, 2. CURRENT file exists but error_if_exists flag is on. fallthrough on success.</h4><h4 id="step4-prepare-the-first-MANIFEST-file-and-configure-VersionSet-object-if-creating-a-new-db"><a href="#step4-prepare-the-first-MANIFEST-file-and-configure-VersionSet-object-if-creating-a-new-db" class="headerlink" title="step4: prepare the first MANIFEST file and configure VersionSet object if creating a new db."></a>step4: prepare the first MANIFEST file and configure VersionSet object if creating a new db.</h4><blockquote>
<ul>
<li>CURRENT file keeps “MANITEST-000001”</li>
<li>MANIFEST-000001 file keeps a sentinel record that contains:<ul>
<li><code>prev_log_number_=0</code></li>
<li><code>log_number_=0</code></li>
<li><code>manifest_file_number_=1</code></li>
<li><code>next_file_number_=1</code></li>
<li><code>last_sequence_=0</code></li>
</ul>
</li>
</ul>
<pre><code>// db/db_impl.cc-176
Status DBImpl::NewDB() {
  VersionEdit new_db;
  new_db.SetComparatorName(user_comparator()-&gt;Name());
  new_db.SetLogNumber(0);
  new_db.SetNextFile(2);
  new_db.SetLastSequence(0);
</code></pre></blockquote>
<pre><code>  const std::string manifest = DescriptorFileName(dbname_, 1);
  WritableFile* file;
  Status s = env_-&gt;NewWritableFile(manifest, &amp;file);
  if (!s.ok()) {
    return s;
  }
  {
    log::Writer log(file);
    std::string record;
    new_db.EncodeTo(&amp;record);
    s = log.AddRecord(record);
    if (s.ok()) {
      s = file-&gt;Close();
    }
  }
  delete file;
  if (s.ok()) {
    // Make &quot;CURRENT&quot; file that points to the new manifest file.
    s = SetCurrentFile(env_, dbname_, 1);
  } else {
    env_-&gt;DeleteFile(manifest);
  }
  return s;
}
</code></pre><h4 id="step5-replay-current-MANIFEST-records-on-VersionSet-object-and-set-manifest-filenumber-to-next-file-number-and-increment-next-file-number-by-1"><a href="#step5-replay-current-MANIFEST-records-on-VersionSet-object-and-set-manifest-filenumber-to-next-file-number-and-increment-next-file-number-by-1" class="headerlink" title="step5: replay current MANIFEST records on VersionSet object and set manifest_filenumber to next_file_number and increment next_file number by 1."></a>step5: replay current MANIFEST records on VersionSet object and set manifest_file<em>number</em> to next_file_number and increment next_file number by 1.</h4><blockquote>
<pre><code>// db/version_set.cc-896 VersionSet::Recover
</code></pre></blockquote>
<h4 id="step6-scan-the-data-directory-return-error-if-any-files-are-missing"><a href="#step6-scan-the-data-directory-return-error-if-any-files-are-missing" class="headerlink" title="step6: scan the data directory,  return error if any files are missing"></a>step6: scan the data directory,  return error if any files are missing</h4><blockquote>
<pre><code>// db/db_impl.cc-318 DBImpl::Recover
  std::vector&lt;std::string&gt; filenames;
  s = env_-&gt;GetChildren(dbname_, &amp;filenames);
  if (!s.ok()) {
    return s;
  }
  std::set&lt;uint64_t&gt; expected;
  versions_-&gt;AddLiveFiles(&amp;expected);
  uint64_t number;
  FileType type;
  std::vector&lt;uint64_t&gt; logs;
  for (size_t i = 0; i &lt; filenames.size(); i++) {
    if (ParseFileName(filenames[i], &amp;number, &amp;type)) {
      expected.erase(number);
      if (type == kLogFile &amp;&amp; ((number &gt;= min_log) || (number == prev_log)))
        logs.push_back(number);
    }
  }
  if (!expected.empty()) {
    char buf[50];
    snprintf(buf, sizeof(buf), &quot;%d missing files; e.g.&quot;,
             static_cast&lt;int&gt;(expected.size()));
    return Status::Corruption(buf, TableFileName(dbname_, *(expected.begin())));
  }
</code></pre></blockquote>
<h4 id="step7-recover-data-from-log-files"><a href="#step7-recover-data-from-log-files" class="headerlink" title="step7: recover data from log files"></a>step7: recover data from log files</h4><blockquote>
<pre><code>// db/db_impl.cc-343 DBImpl::Recover
// Recover in the order in which the logs were generated
  std::sort(logs.begin(), logs.end());
  for (size_t i = 0; i &lt; logs.size(); i++) {
    s = RecoverLogFile(logs[i], (i == logs.size() - 1), save_manifest, edit,
                       &amp;max_sequence);
    if (!s.ok()) {
      return s;
    }

    // The previous incarnation may not have written any MANIFEST
    // records after allocating this log number.  So we manually
    // update the file number allocation counter in VersionSet.
    versions_-&gt;MarkFileNumberUsed(logs[i]);
  }
</code></pre></blockquote>
<h4 id="step8-reuse-the-last-log-file-MemTable-or-create-new-a-log-file-MemTable"><a href="#step8-reuse-the-last-log-file-MemTable-or-create-new-a-log-file-MemTable" class="headerlink" title="step8: reuse the last log file/MemTable or create new a log file/MemTable"></a>step8: reuse the last log file/MemTable or create new a log file/MemTable</h4><blockquote>
<pre><code>// db/db_impl.cc-453 DBImpl::RecoverLogFile
  // See if we should keep reusing the last log file.
  if (status.ok() &amp;&amp; options_.reuse_logs &amp;&amp; last_log &amp;&amp; compactions == 0) {
    assert(logfile_ == NULL);
    assert(log_ == NULL);
    assert(mem_ == NULL);
    uint64_t lfile_size;
    if (env_-&gt;GetFileSize(fname, &amp;lfile_size).ok() &amp;&amp;
        env_-&gt;NewAppendableFile(fname, &amp;logfile_).ok()) {
      Log(options_.info_log, &quot;Reusing old log %s \n&quot;, fname.c_str());
      log_ = new log::Writer(logfile_, lfile_size);
      logfile_number_ = log_number;
      if (mem != NULL) {
        mem_ = mem;
        mem = NULL;
      } else {
        // mem can be NULL if lognum exists but was empty.
        mem_ = new MemTable(internal_comparator_);
        mem_-&gt;Ref();
      }
    }
  }

  if (mem != NULL) {
    // mem did not get reused; compact it.
    if (status.ok()) {
      *save_manifest = true;
      status = WriteLevel0Table(mem, edit, NULL);
    }
    mem-&gt;Unref();
  }


// db/db_impl.cc-1499 DB::Open
  if (s.ok() &amp;&amp; impl-&gt;mem_ == NULL) {
    // Create new log and a corresponding memtable.
    uint64_t new_log_number = impl-&gt;versions_-&gt;NewFileNumber();
    WritableFile* lfile;
    s = options.env-&gt;NewWritableFile(LogFileName(dbname, new_log_number),
                                     &amp;lfile);
    if (s.ok()) {
      edit.SetLogNumber(new_log_number);
      impl-&gt;logfile_ = lfile;
      impl-&gt;logfile_number_ = new_log_number;
      impl-&gt;log_ = new log::Writer(lfile);
      impl-&gt;mem_ = new MemTable(impl-&gt;internal_comparator_);
      impl-&gt;mem_-&gt;Ref();
    }
  }
</code></pre></blockquote>
<h4 id="step9-create-a-new-MANIFEST-file-if-reuse-logs-flag-is-off-or-the-old-MANIFEST-file-is-too-large"><a href="#step9-create-a-new-MANIFEST-file-if-reuse-logs-flag-is-off-or-the-old-MANIFEST-file-is-too-large" class="headerlink" title="step9: create a new MANIFEST file if reuse_logs flag is off or the old MANIFEST file is too large."></a>step9: create a new MANIFEST file if reuse_logs flag is off or the old MANIFEST file is too large.</h4><blockquote>
<pre><code>// db/version_set.cc-1007 VersionSet::Recover
    // See if we can reuse the existing MANIFEST file.
    if (ReuseManifest(dscname, current)) {
      // No need to save new manifest
    } else {
      *save_manifest = true;
    }


// db/version_set.cc-1018 VersionSet::ReuseManifest
bool VersionSet::ReuseManifest(const std::string&amp; dscname,
                               const std::string&amp; dscbase) {
  if (!options_-&gt;reuse_logs) {
    return false;
  }
  FileType manifest_type;
  uint64_t manifest_number;
  uint64_t manifest_size;
  if (!ParseFileName(dscbase, &amp;manifest_number, &amp;manifest_type) ||
      manifest_type != kDescriptorFile ||
      !env_-&gt;GetFileSize(dscname, &amp;manifest_size).ok() ||
      // Make new compacted MANIFEST if old one is too big
      manifest_size &gt;= kTargetFileSize) {
    return false;
  }

  assert(descriptor_file_ == NULL);
  assert(descriptor_log_ == NULL);
  Status r = env_-&gt;NewAppendableFile(dscname, &amp;descriptor_file_);
  if (!r.ok()) {
    Log(options_-&gt;info_log, &quot;Reuse MANIFEST: %s\n&quot;, r.ToString().c_str());
    assert(descriptor_file_ == NULL);
    return false;
  }

  Log(options_-&gt;info_log, &quot;Reusing MANIFEST %s\n&quot;, dscname.c_str());
  descriptor_log_ = new log::Writer(descriptor_file_, manifest_size);
  manifest_file_number_ = manifest_number;
  return true;
}


// db/db_impl.cc-1514 DB::Open
  if (s.ok() &amp;&amp; save_manifest) {
    edit.SetPrevLogNumber(0);  // No older logs needed after recovery.
    edit.SetLogNumber(impl-&gt;logfile_number_);
    s = impl-&gt;versions_-&gt;LogAndApply(&amp;edit, &amp;impl-&gt;mutex_);
  }


// db/version_set.cc-834 VersionSet::LogAndApply
  // Initialize new descriptor log file if necessary by creating
  // a temporary file that contains a snapshot of the current version.
  std::string new_manifest_file;
  Status s; 
  if (descriptor_log_ == NULL) {
    // No reason to unlock *mu here since we only hit this path in the
    // first call to LogAndApply (when opening the database).
    assert(descriptor_file_ == NULL);
    new_manifest_file = DescriptorFileName(dbname_, manifest_file_number_);
    edit-&gt;SetNextFile(next_file_number_);
    s = env_-&gt;NewWritableFile(new_manifest_file, &amp;descriptor_file_);
    if (s.ok()) {
      descriptor_log_ = new log::Writer(descriptor_file_);
      s = WriteSnapshot(descriptor_log_);
    }
  }
</code></pre></blockquote>
<h4 id="step10-delete-obsolete-files-and-trigger-background-compaction"><a href="#step10-delete-obsolete-files-and-trigger-background-compaction" class="headerlink" title="step10: delete obsolete files and trigger background compaction"></a>step10: delete obsolete files and trigger background compaction</h4><h4 id="step11-return-the-DBImpl-object-for-manipulating-leveldb"><a href="#step11-return-the-DBImpl-object-for-manipulating-leveldb" class="headerlink" title="step11: return the DBImpl object for manipulating leveldb"></a>step11: return the DBImpl object for manipulating leveldb</h4><hr>
<h3 id="graceful-termination"><a href="#graceful-termination" class="headerlink" title="graceful termination"></a>graceful termination</h3><p>set <code>DBImpl::shutting_down_</code> to a non-NULL value</p>
<blockquote>
<pre><code>// db/db_impl.cc-147
DBImpl::~DBImpl() {
  // Wait for background work to finish
  mutex_.Lock();
  shutting_down_.Release_Store(this);  // Any non-NULL value is ok
  while (bg_compaction_scheduled_) {
    bg_cv_.Wait();
  }
  mutex_.Unlock();

  if (db_lock_ != NULL) {
    env_-&gt;UnlockFile(db_lock_);
  }

  delete versions_;
  if (mem_ != NULL) mem_-&gt;Unref();
  if (imm_ != NULL) imm_-&gt;Unref();
  delete tmp_batch_;
  delete log_;
  delete logfile_;
  delete table_cache_;

  if (owns_info_log_) {
    delete options_.info_log;
  }
  if (owns_cache_) {
    delete options_.block_cache;
  }
}
</code></pre></blockquote>
<p>The backgroud compaction thread  checks <code>shutting_down_</code> before it goes ahead and stops compacting on its own if <code>shutting_down_</code> is set. </p>
<p>DBImpl dtor waits for the compaction thread to cease, then release the file lock and memory, close files.</p>
<h3 id="RepairDB"><a href="#RepairDB" class="headerlink" title="RepairDB"></a>RepairDB</h3><blockquote>
<pre><code>// db/repair.cc-456
Status RepairDB(const std::string&amp; dbname, const Options&amp; options) {
  Repairer repairer(dbname, options);
  return repairer.Run();
}


// db/repair.cc-70        
  Status Run() {
    Status status = FindFiles();
    if (status.ok()) {
      ConvertLogFilesToTables();
      ExtractMetaData();
      status = WriteDescriptor();
    }   
    if (status.ok()) {
      unsigned long long bytes = 0;
      for (size_t i = 0; i &lt; tables_.size(); i++) {
        bytes += tables_[i].meta.file_size;
      }   
      Log(options_.info_log,
          &quot;**** Repaired leveldb %s; &quot;
          &quot;recovered %d files; %llu bytes. &quot;
          &quot;Some data may have been lost. &quot;
          &quot;****&quot;,
          dbname_.c_str(),
          static_cast&lt;int&gt;(tables_.size()),
          bytes);
    }   
    return status;
  }
</code></pre></blockquote>
<p><strong>key points</strong></p>
<ul>
<li>scan child files in db data directory, and classify these files into logs, SSTables and MANIFESTs.</li>
<li>convert log files into SSTable files.</li>
<li>iterate the key&amp;value of each SSTable, try the best to recovey the SSTable on error.</li>
<li>Add all valid SSTables info level-0 and write manifest.</li>
</ul>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/leveldb/" rel="tag"># leveldb</a>
          
            <a href="/tags/wal/" rel="tag"># wal</a>
          
            <a href="/tags/storage/" rel="tag"># storage</a>
          
            <a href="/tags/key-value/" rel="tag"># key-value</a>
          
            <a href="/tags/lsm/" rel="tag"># lsm</a>
          
        </div>
      

      
      
      

      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
  <a class="jiathis_button_tqq"></a>
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <a class="jiathis_button_douban"></a>
  <a class="jiathis_button_renren"></a>
  <a class="jiathis_button_qzone"></a>
  <a class="jiathis_button_kaixin001"></a>
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/avatar.jpg"
               alt="grakra" />
          <p class="site-author-name" itemprop="name">grakra</p>
           
              <p class="site-description motion-element" itemprop="description">grakra</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="/wechat" target="_blank" title="Wechat">
                  
                    <i class="fa fa-fw fa-wechat"></i>
                  
                  Wechat
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/grakra" target="_blank" title="Zhihu">
                  
                    <i class="fa fa-fw fa-zhihu"></i>
                  
                  Zhihu
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://github.com/satanson" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#LevelDB-Read-the-Fucking-Source-Code"><span class="nav-number">1.</span> <span class="nav-text">LevelDB: Read the Fucking Source Code.</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#by-grakra"><span class="nav-number">1.1.</span> <span class="nav-text">by grakra</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Example"><span class="nav-number">1.2.</span> <span class="nav-text">Example</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#build-leveldb-library"><span class="nav-number">1.2.1.</span> <span class="nav-text">build leveldb library</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#demo"><span class="nav-number">1.2.2.</span> <span class="nav-text">demo</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Build-Demo"><span class="nav-number">1.2.3.</span> <span class="nav-text">Build Demo</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Overview"><span class="nav-number">1.3.</span> <span class="nav-text">Overview</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Features"><span class="nav-number">1.3.1.</span> <span class="nav-text">Features</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Inventory-of-data-directory"><span class="nav-number">1.3.2.</span> <span class="nav-text">Inventory of data directory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Architecture"><span class="nav-number">1.3.3.</span> <span class="nav-text">Architecture</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LSM-Log-Structured-Merge-tree"><span class="nav-number">1.4.</span> <span class="nav-text">LSM (Log-Structured Merge tree)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WAL-Write-Ahead-Logging"><span class="nav-number">1.5.</span> <span class="nav-text">WAL (Write-Ahead Logging)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sketch-of-WAL"><span class="nav-number">1.5.1.</span> <span class="nav-text">sketch of WAL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WAL-in-LevelDB"><span class="nav-number">1.5.2.</span> <span class="nav-text">WAL in LevelDB</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#features"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">features</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#log-format"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">log format</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#implementation"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">implementation</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DB-manipulation"><span class="nav-number">1.6.</span> <span class="nav-text">DB manipulation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Write"><span class="nav-number">1.6.1.</span> <span class="nav-text">1.Write</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MemTable"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">MemTable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SkipList"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">SkipList</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Compaction"><span class="nav-number">1.6.2.</span> <span class="nav-text">2.Compaction</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LevelDB-SSTable-Layout"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">LevelDB SSTable Layout</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#When-to-do-compaction"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">When to do compaction</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Minor-compaction-CompactMemTable"><span class="nav-number">1.6.2.3.</span> <span class="nav-text">Minor compaction: CompactMemTable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Major-compaction-PickCompaction-and-DoCompactionWork"><span class="nav-number">1.6.2.4.</span> <span class="nav-text">Major compaction: PickCompaction and DoCompactionWork</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Read"><span class="nav-number">1.6.3.</span> <span class="nav-text">3.Read</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-Get-operation-Get-a-single-Key-Value"><span class="nav-number">1.6.3.1.</span> <span class="nav-text">3.1 Get operation: Get a single Key-Value</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-NewIterator-Scan-a-batch-of-Key-Values"><span class="nav-number">1.6.3.2.</span> <span class="nav-text">3.2 NewIterator: Scan a batch of Key-Values</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Open"><span class="nav-number">1.7.</span> <span class="nav-text">Open</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DB-is-opened-in-3-situations"><span class="nav-number">1.7.1.</span> <span class="nav-text">DB is opened in 3 situations</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DB-Open-demo"><span class="nav-number">1.7.2.</span> <span class="nav-text">DB::Open demo</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Customize-DB-by-configuring-leveldb-Options"><span class="nav-number">1.7.3.</span> <span class="nav-text">Customize DB by configuring leveldb::Options</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Implementation-of-DB-Open"><span class="nav-number">1.7.4.</span> <span class="nav-text">Implementation of DB::Open</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#step1-instantiate-a-DBImpl-object"><span class="nav-number">1.7.4.1.</span> <span class="nav-text">step1: instantiate a DBImpl object</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#step2-create-db-data-directory-and-require-file-lock-on-LOCK-file"><span class="nav-number">1.7.4.2.</span> <span class="nav-text">step2: create db data directory and require file lock on LOCK file.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#step3-return-on-error-in-two-cases-1-no-CURRENT-file-exists-but-create-if-missing-flag-is-off-2-CURRENT-file-exists-but-error-if-exists-flag-is-on-fallthrough-on-success"><span class="nav-number">1.7.4.3.</span> <span class="nav-text">step3: return on error in two cases: 1. no CURRENT file exists but create_if_missing flag is off, 2. CURRENT file exists but error_if_exists flag is on. fallthrough on success.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#step4-prepare-the-first-MANIFEST-file-and-configure-VersionSet-object-if-creating-a-new-db"><span class="nav-number">1.7.4.4.</span> <span class="nav-text">step4: prepare the first MANIFEST file and configure VersionSet object if creating a new db.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#step5-replay-current-MANIFEST-records-on-VersionSet-object-and-set-manifest-filenumber-to-next-file-number-and-increment-next-file-number-by-1"><span class="nav-number">1.7.4.5.</span> <span class="nav-text">step5: replay current MANIFEST records on VersionSet object and set manifest_filenumber to next_file_number and increment next_file number by 1.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#step6-scan-the-data-directory-return-error-if-any-files-are-missing"><span class="nav-number">1.7.4.6.</span> <span class="nav-text">step6: scan the data directory,  return error if any files are missing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#step7-recover-data-from-log-files"><span class="nav-number">1.7.4.7.</span> <span class="nav-text">step7: recover data from log files</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#step8-reuse-the-last-log-file-MemTable-or-create-new-a-log-file-MemTable"><span class="nav-number">1.7.4.8.</span> <span class="nav-text">step8: reuse the last log file/MemTable or create new a log file/MemTable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#step9-create-a-new-MANIFEST-file-if-reuse-logs-flag-is-off-or-the-old-MANIFEST-file-is-too-large"><span class="nav-number">1.7.4.9.</span> <span class="nav-text">step9: create a new MANIFEST file if reuse_logs flag is off or the old MANIFEST file is too large.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#step10-delete-obsolete-files-and-trigger-background-compaction"><span class="nav-number">1.7.4.10.</span> <span class="nav-text">step10: delete obsolete files and trigger background compaction</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#step11-return-the-DBImpl-object-for-manipulating-leveldb"><span class="nav-number">1.7.4.11.</span> <span class="nav-text">step11: return the DBImpl object for manipulating leveldb</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#graceful-termination"><span class="nav-number">1.7.5.</span> <span class="nav-text">graceful termination</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RepairDB"><span class="nav-number">1.7.6.</span> <span class="nav-text">RepairDB</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">grakra</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
